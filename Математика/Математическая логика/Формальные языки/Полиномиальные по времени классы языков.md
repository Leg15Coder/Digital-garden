==Опр.== $A \in DTIME(f)$ $\Leftrightarrow$ $A$ [[Задачи решаемые на МТ#Задача разрешения (распознавания)|распознаётся]] на [[Вариации МТ#Недетерминированная МТ (НМТ)|ДМТ]] за $T_A = O(f)$

==Опр.== $A \in NTIME(f)$ $\Leftrightarrow$ $A$ [[Задачи решаемые на МТ#Задача разрешения (распознавания)|распознаётся]] на [[Вариации МТ#Недетерминированная МТ (НМТ)|НМТ]] за $T_A = O(f)$

> [!tip] Лемма о переходе от НМТ к ДМТ
> Если $T$ [[Задачи решаемые на МТ#^f4d646|конструируема по времени]], то $NTIME(T) \subseteq DTIME(2^{O(T)})$

==Опр.== $f(n) = poly(g(n))$ $\Leftrightarrow$ $\exists c \in \mathbb{N}_0\ :\ f(n) = O(g^c(n))$

==Опр.== $f = poly(g)$ $\Leftrightarrow$ $\forall n \in \mathbb{N}\ :\ f(n) = poly(g(n))$

==Опр.== $f(n) = polylog(g(n))\ f = polylog(g)$ $\Leftrightarrow$ $\exists c \in \mathbb{N}_0\ :\ f(n) = O(log^c(g(n)))$

==Опр.== $f = polylog(g)$ $\Leftrightarrow$ $\forall n \in \mathbb{N}\ :\ f(n) = polylog(g(n))$

==Опр.== $f(n) = \widetilde{O}(g(n))$ $\Leftrightarrow$ $f(n) = O(g(n) \cdot polylog(g(n)))$

==Опр.== $f = \widetilde{O}(g)$ $\Leftrightarrow$ $f(n) = \forall n \in \mathbb{N}\ :\ f(n) = \widetilde{O}(g(n))$

==Опр.== **$P$** $= DTIME(poly(n))$

==Опр.== **$NP$** $= NTIME(poly(n))$

## Сертификатное определение $NP$
### Определение

- $A \in NP$ $\Longleftrightarrow$ $\exists V : \Sigma^* \times \Sigma^* \to B$ т.ч. $V(w, s) = poly(|w|)$ и $\forall w \in \Sigma^*\ :$ $(w \in A$ $\Leftrightarrow$ $\exists s \in \Sigma^*\ :\ V(w, s) = 1)$

В определении принято называть:
- $V$ - **верификатор**, а
- $s$ - **сертификат**

### Эквивалентность определений
#### Из основного следует сертификатное

Пусть НМТ $M$ распознаёт $A$ за $T(n) = O(n^c) = poly(n)$, тогда если $w \in A$, то существует последовательность конфигураций $s$ т.ч. они последовательно описывают ту ветку, в которой $M$ принимает слово $w$, а так как по предположению $M$ в каждой ветке работает полиномиальное количество шагов, то $\exists k > 0\ :\ |s| \leq k|w|^c$. В качестве сертификата возьмём как раз $s$ - последовательность конфигураций, а верификатор $V$ будет устроен следующим образом:
1) По входу $w$ и сертификату $s$ верификатор начинает эмулировать работу $M$
2) Сертификат разбивается на отдельные конфигурации и для каждой следующей конфигурации проверяется:
	1) Корректная ли это конфигурация (синтаксически)
	2) Возможно ли её получить из предыдущей
	3) Для последней конфигурации дополнительно происходит проверка состояния: финальное ли оно
3) Поскольку размер сертификата полиномиально зависит только от $w$, а количество тактов работы $V$ зависит от $s$ и $M$, то $V$ будет работать за полином от первого аргумента

Заметим, что $\exists s\ :\ V(w, s) = 1$ $\Leftrightarrow$ $\exists$ ветка работы $M$, принимающая $w$, а так как $M$ разрешает $A$, то $w \in A$ $\Leftrightarrow$ $\exists s\ :\ V(w, s) = 1$

#### Из сертификатного следует основное

Пусть для некоторого $A \subset \Sigma^*$ верно, что $\exists V : \Sigma^* \times \Sigma^* \to B$ т.ч. $V(w, s) = poly(|w|)$ и $\forall w \in \Sigma^*\ :$ $(w \in A$ $\Leftrightarrow$ $\exists s \in \Sigma^*\ :\ V(w, s) = 1)$. Заметим, что $V$ не сможет считать более $poly(|w|)$ символов $s$, поэтому все символы дальше никогда не будут прочитаны и не смогут повлиять на работу программы. Тогда, ограничим длину $s$, отбросив все незначимые символы: $|s| = q(|w|) = poly(|w|)$. Построим НМТ $M$, распознающую $A$:
1) Считав вход $w$, $M$ заводит счётчик $cnt = 0$
2) $M$ создаёт специальную ленту
3) Пока $cnt < q(|w|)$ в каждой ветке происходит следующее: 
	1) $M$ создаёт $|\Sigma|$ веток
	2) в каждой ветке на специальной ленте дописывается один символ (в каждой созданной ветке символ уникален)
	3) $cnt = cnt + 1$
4) Обозначим слово, получившееся на специальной ленте переменной $s$
5) В каждой созданной ветке $M$ запускает $V(w, s)$ и принимает слово только если $V(w, s) = 1$

Заметим, что время работы в каждой ветке $= q(|w|) + T_V(|w|) + const = O(poly(|w|))$, а $w$ принимается $\Leftrightarrow$ $\exists s\ :\ V(w, s) = 1$ $\Leftrightarrow$ $w \in A$.

#### Замечание

- Есть несколько вариаций сертификатного определения. Например, можно потребовать, чтобы $s \in \Sigma^{q(|w|)}$, где $q(n) = poly(n)$.

## Отношения $P$ и $NP$

> [!tip] Факт вложенности
> $P \subseteq NP \cap coNP$
- Любая задача из $P$ решается детерминированно за полиномиальное время, а значит её решение можно верифицировать за полиномиальное время, просто проигнорировав сертификат и запустив решающий алгоритм.

> [!warning] Гипотеза неравенства *(не доказано)*
> $P \neq NP$

> [!warning] Гипотеза неравенства *(не доказано)*
> $NP \neq coNP$
