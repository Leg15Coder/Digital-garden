- $SAT = \{\varphi\ |\ \varphi\ -$ [[Понятие формулы|выполнимая булева формула]] в виде КНФ $\} \in NPC$

### Доказательство

Пусть $\varphi$ - некоторая булева формула. Пусть $x_1, \dots, x_n$ - переменные, входящие в эту формулу. Очевидно, что $\forall i \in \overline{1,n}\ :\ |x_i| \leq |\varphi|$ и $n \leq |\varphi|$. Тогда НМТ $M$, разрешающая $SAT$ может работать следующим образом:
1) Для каждого $i \in \overline{1,n}$:
	1) Для каждой имеющейся ветки создать две ветки: 
		1) В первой $x_i = 0$
		2) Во второй $x_i = 1$
	2) В каждой ветке нужно упростить формулу (это можно сделать за $O(|\varphi|)$)
	3) В каждой ветке присвоений значений в переменную - $n$, а каждое присвоение влечёт упрощение за $O(|\varphi|)$, то есть каждая заканчивает работать через $O(n|\varphi|) = poly(|\varphi|)$
$M$ работает за полином, следовательно $SAT \in NP$

Пусть $A \in NP$. Пусть ДМТ $V$ - односторонний одноленточный верификатор $A$, размер сертификата к которому $q(|x|)$. $V(x, s)$ работает за $p(|x|) = poly(|x|)$, то есть в протоколе работы $V$ не более $p(|x|) + 1$ конфигураций, при этом $V$ ни в какой момент времени не сможет задействовать более $(|x| + |s| + p(|x|) + const)$ $=p'(|x|) = poly(|x|)$ ячеек ленты. 

Символ конфигурации кодируется в алфавите $\Sigma' = \Sigma \sqcup Q$ $\Rightarrow$ $m = \lceil\log_2 |\Sigma'|\rceil = const$ - количество бит для записи символа конфигурации в двоичной СС. Будем кодировать символы конфигурации в двоичной СС, причём все символы из $Q$ кодируются двоичными числами не меньше $r$ (причём $q_0$ кодируется как $r$), а из $\Sigma$ - строго меньше $r$. Пусть $w_{ij}$ - $j$-й символ конфигурации (индексация с 1, начиная с самой левой посещённой ячейки) на $i$-м такте работы (индексация с 0). Тогда мы можем завести таблицу размера $p(|x|) \times p'(|x|)$, куда запишем протокол работы верификатора:

|     $w_{0,1}$     |     $w_{0,2}$     |     $w_{0,3}$     | $\dots$  |    $w_{0, p'(\|x\|)}$     |
| :---------------: | :---------------: | :---------------: | :------: | :-----------------------: |
|     $w_{1,1}$     |     $w_{1,2}$     |     $w_{1,3}$     | $\dots$  |     $w_{1,p'(\|x\|)}$     |
|     $\vdots$      |     $\vdots$      |     $\vdots$      | $\ddots$ |         $\vdots$          |
| $w_{p(\|x\|), 1}$ | $w_{p(\|x\|), 2}$ | $w_{p(\|x\|), 3}$ | $\dots$  | $w_{p(\|x\|), p'(\|x\|)}$ |

По данной таблице построим булеву формулу в следующем формате:
1) Каждая ячейка таблицы - отдельная булева переменная.
2) Операции в формуле проверяют следующие факты:
	1) Первая строка содержит корректную стартовую конфигурацию
	2) Все переходы между строками корректны
	3) В последней строке есть финальное состояние

Чтобы проверить корректность стартовой конфигурации, нужно:
1) $w_{1,1} = r$ - первый символ - стартовое состояние МТ
2) $(w_{0, 0} < r) \wedge \bigwedge\limits_{i=2}^{p'(|x|)}(w_{0, i} < r)$ - все остальные символы - часть алфавита

Для проверки корректности всех переходов воспользуемся таблицей переходов $V$:
Рассмотрим $w_{i,j}$. Его можно **однозначно** определить из $w_{i-1, j-2}$, $w_{i-1, j-1}$, $w_{i-1, j}$ и $w_{i-1, j+1}$ по таблице переходов:
- Будем обозначать: $a, b, c, d, a', b', c', d' \in \Sigma$; $q, q' \in Q$.
- Если $w_{i-1, j-2}w_{i-1, j-1}w_{i-1, j}w_{i-1, j+1} =$
	1) $abcd$ или $qbcd$, то $w_{i, j} = c$
	
	2) $aqbc$, то $w_{i, j} =$ $\begin{cases} b, & \delta(a, q) = (a', -1, q') \\ b, &  \delta(a, q) = (a', 0, q') \\ q', &  \delta(a, q) = (a', +1, q') \end{cases}$
	
	3) $abqc$, то $w_{i, j} =$ $\begin{cases} b', &  \delta(b, q) = (b', -1, q') \\ q', &  \delta(b, q) = (b', 0, q') \\ c, &  \delta(b, q) = (b', +1, q') \end{cases}$
	
	4) $abcq$, то $w_{i, j} =$ $\begin{cases} q', &  \delta(c, q) = (c', -1, q') \\ c', &  \delta(c, q) = (c', 0, q') \\ c', &  \delta(c, q) = (c', +1, q') \end{cases}$
- Если ячейка одна из первых двух - то она обрабатывается отдельно, но по полной аналогии.

- То есть для проверки корректности каждой ячейки достаточно добавить в КНФ упрощённую до вида КНФ формулы: $((w_{i-1, j-2} == a \wedge w_{i-1, j-1} == b \wedge w_{i-1, j} == c \wedge w_{i-1, j+1} == d) \to (w_{i, j} == y))$ для каждого возможного набора $a$, $b$, $c$, $d$ и соответствующего им $y$. Для каждой ячейки таких импликаций $\leq (2^m)^4 = const$

Осталось проверить, что в последней конфигурации содержится финальное принимающее состояние $q_{yes}$ (для простоты будем считать что оно одно и имеет код $r'$). Это проверяется следующим дизъюнктом: $\bigvee\limits_{i=1}^{p'(|x|)}(w_{p(|x|, i)} == r')$

Итак, пусть ДМТ $M$ по входу $x$ выполняет все описанные выше операции:
0) $\delta, Q, \Sigma$ сохранены в памяти $M$, так что просто служебная подготовка. Заметим, что $p''(|x|) = p(|x|) \cdot p'(|x|) = poly(|x|)$
1) Строит таблицу протокола работы $V(x, s)$ (так как значения ячеек сертификата не известны, то таблица *мнимая*, то есть без конкретных значений в ней) (это выполняется за $O(p''(|x|))$)
2) Начинает создавать формулу, выписывая необходимые условия корректности начальной конфигурации, переходов и наличия финального состояния (это выполняется за $O(p''(|x|))$)
3) Выполняет конъюнкцию всех выписанных условий, получая булеву формулу $\varphi$ (это выполняется за $O(p''(|x|))$ так как условий $O(p''(|x|))$)
- Таким образом $M$ работает за $O(poly(|x|))$

Проанализируем $\varphi$:
1) Если она выполнима, значит:
	1) Существует сертификат $s$, который можно подставить и при этом начальная конфигурация будет корректна
	2) При данном $s$ все переходы корректны, значит по индукции все конфигурации корректны
	3) При данном $s$ в последней конфигурации есть состояние $q_{yes}$ и конфигурация корректна $\Rightarrow$ $V(x, s) = 1$ 
	4) $V(x, s) = 1$ $\Leftrightarrow$ $x \in A$
2) Если невыполнима, то:
	1) Ни при каком сертификате нет такого протокола работы $V$, что он завершался бы принятием $x$

То есть $x \in A \Leftrightarrow M(x) = \varphi \in SAT$ $\Longrightarrow$ $A \leq_p SAT$ $\Longrightarrow$ $SAT \in NPC$ 
