$$NL = coNL$$

### Доказательство

[[PATH|Известен]] факт: $PATH \in NLC$, значит $\overline{PATH} \in coNLC$. Докажем, что $\overline{PATH} \in NLC$ из чего следует, что $NLC = coNLC$ ($NL = coNL$).

Построим НМТ $M$, которая разрешает $\overline{PATH}$ на логарифмической памяти и работает следующим образом:
1) Введём функцию $is\_connected(u, v)$, которая проверяет есть ли ребро $(u, v)$ в графе за $O(0)$ доппамяти (просто проверяет все рёбра)

2) Введём функцию $check\_path(u, v, k)$, которая проверяет есть ли путь из $u$ в $v$ длины не более $k$ и работает недетерминированно следующим образом:
	1) Если $k \leq 0$, то возвращает $q_{no}$
	2) Перебирает всех соседей $u$ и для каждого соседа (назовём соседа $w$, вершина является соседом, если $is\_connected(u, w)$ верно):
		1) Если $w == v$, то возвращает $q_{yes}$
		2) иначе запускает в новой ветке $check\_path(w, v, k - 1)$
	- В каждой ветке достаточно хранить текущую вершину (выбранного соседа) и счётчик $k$, что составляет $O(\log k)$ доппамяти

3) Введём функцию $is\_correct\_branch(u, v, S, k)$, которая проверяет есть ли путь из $u$ в $v$ длины не более $k$ и работает недетерминированно следующим образом:
	1) Заводим счётчик $cnt = 0$
	2) Заводим булевый флаг $was\_reached = false$
	3) Для каждой вершины $w$ в графе:
		1) Если верно, что $check\_path(u, w, k-1)$, то
			1) $cnt = cnt + 1$
			2) Если ещё и верно, что $is\_connected(w, v)$, то
				1) $was\_reached := true$
	4) Если $cnt == S$ и $was\_reached == true$, то возвращает $q_{yes}$, а иначе $q_{no}$
	- Здесь $S$ - это количество вершин, достижимых из $u$ за не более чем $k - 1$ рёбер. Если вдруг $S \neq cnt$, то мы посетили не все вершины, до которых расстояние $k-1$, то есть не факт, что мы нашли нужную вершину (это может произойти так как мы не эмулируем функцию $check\_path$, а просто запускаем её inline. Эмуляция требует $O(\log^2 k)$ памяти, поскольку недетерминированно невозможно узнать итоговый результат всех веток вычислений). 
	- Здесь нам нужно хранить только $cnt$, флаг, текущую обрабатываемую в цикле вершину и память вызываемой функции, что занимает $O(\log S + \log k)$ доппамяти

4) Сама $M$ работает следующим образом: заводит счётчик $S = 1$ - количество вершин, достижимых из начальной вершины $s$ за не более чем $0$ рёбер
5) Для всех $k \in \overline{1, n-1}$:
	1) Для каждой вершины $v$ графа:
		1) Если $is\_correct\_branch(s, v, S, k)$:
			1) $S = S + 1$
6) Если $is\_correct\_branch(s, t, S, |V|)$, то возвращает $q_{no}$, иначе - $q_{yes}$
- В итоге мы храним только два счётчика размера $O(\log |V|)$, текущую вершину и память вызываемой функции, которая тоже занимает $O(\log |V|)$, то есть $M$ занимает не более $O(\log n)$ ячеек памяти.

### Следствия

- $A \in NL$ $\Rightarrow$ $\overline{A} \in NL$
- $A \in NLC$ $\Rightarrow$ $\overline{A} \in NLC$
- $A \in coNLC$ $\Rightarrow$ $\overline{A} \in coNLC$
