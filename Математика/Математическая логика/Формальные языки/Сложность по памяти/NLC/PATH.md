- $DPATH \equiv PATH = \{ (G, s, t)\ |\ \text{в графе}\ G\ \text{есть путь из}\ s\ \text{в}\ t \} \in NLC$

#### Доказательство

Опишем НМТ $M$, разрешающую $PATH$ и работающую на логарифмической памяти:
1) Пусть $u$ - текущая вершина. (изначально $u = s$)
2) Заводим счётчик $k = 0$
3) Пока $k \leq |V|$:
	1) Если $u == t$, то $M$ возвращает $q_{yes}$
	2) Для каждой вершины $v$ в графе:
		1) Если в графе есть ребро $(u, v)$, то создаём новую ветку, в которой:
			1) Присваиваем $u := v$
			2) Увеличиваем счётчик $k = k + 1$

- Поскольку всего вершин в графе $|V|$, то любая достижимая вершина на расстоянии не более $|V| - 1$, а так как мы недетерминированно проходим все пути длины не более $|V|$ из $s$, то если $t$ достижима, то $q_{yes}$ обязательно вернулось.
- $M$ в каждой ветке хранит только счётчик, размер которого $O(\log |V|)$ и две вершины: текущую и следующую, то есть $M$ работает на логарифмической памяти, то есть $PATH \in NL$

Пусть $A \in NL$, а НМТ $M_A$, работающая на логарифмической памяти, разрешает $A$, тогда оценим количество конфигураций в работе $M_A(x)$ ($n = |x|$):
- Количество различных положений головки на входной ленте - $n$
- Количество различных положений головки на рабочей ленте - $O(\log n)$
- Количество различных состояний головки - $|Q|$
- Количество различных состояний рабочей ленты - $|\Sigma|^{O(\log n)}$
Итого количество различных конфигураций $= O(n\log n) \cdot |\Sigma|^{O(\log n)}$ $= O(poly(n))$, то есть для записи одной конфигурации достаточно потратить $m = O(\log (poly(n)))$ $= O(\log n)$ бит

Построим функцию $f$, вычислимую на логарифмической памяти, которая по входу $x$ делает следующее:
1) Вычисляет максимальное количество конфигураций (банальными операциями, возможно сделать на логарифмической памяти). Записывает каждую конфигурацию как отдельную вершину графа, начальную конфигурацию помечает как вершину $s$
2) Добавляет вершину $t$, рёбра в неё из всех тех и только тех вершин, в конфигурациях которых есть принимающее состояние $q_{yes}$ (требует $O(1)$ доппамяти)
3) Для каждой пары конфигураций $u$ и $v$ проверяет по таблице переходов в $M_A$ можно ли получить из $u$ $v$ одним переходом, и если можно, то добавляет ребро $(u, v)$ в граф (достаточно хранить только два счётчика по вершинам - $O(\log n)$ доппамяти)
- Таким образом, в построенном графе есть путь из $s$ в $t$ $\Leftrightarrow$ в графе конфигураций можно попасть из начальной конфигурации в принимающую $\Leftrightarrow$ $x \in A$
То есть $\forall A \in NL\ :\ A \leq_l PATH$ $\Rightarrow$ $PATH \in NLC$
