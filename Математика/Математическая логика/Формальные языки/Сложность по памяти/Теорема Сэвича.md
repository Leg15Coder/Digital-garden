$$\forall s(n) \geq \log n\ :\ NSPACE(s) \subseteq DSPACE(s^2)$$

### Доказательство

Пусть $A \in$ [[Сложность алгоритмов по памяти|NSPACE(s)]] и распознаётся НМТ $M$, используя $S = O(s)$ ячеек памяти. Наложим на $M$ следующие ограничения (это возможно, поскольку $\exists$ эквивалентная НМТ с этими ограничениями):
- Используется ровно одна лента
- Ячейки, в которые записано входное слово, можно только читать, то есть нельзя изменять
- После получения финального состояния ($q_{yes}$/$q_{no}$), МТ стирает все символы, кроме символов входного слова, и останавливает головку в начальной (первой) ячейке. Таким образом, для фиксированного входного слова $x$ есть всего две возможные конечные конфигурации: $x_0q_{yes}x_1\dots x_{n-1}$ и $x_0q_{no}x_1\dots x_{n-1}$

Пусть $x$ - входное слово $M$, т.ч. $|x| = n$. Оценим количество различных конфигураций в работе $M$ над $x$:
1) Максимальное количество использованных ячеек $n + S(n)$
2) Количество различных способов выбрать положение головки: $n + S(n)$
3) Количество различных состояний головки при этом: $|Q|$
4) Количество различных символов, которые могут быть записаны на ленте в процессе её работы: $|\Sigma|^{S(n)}$ - поскольку входное слово не доступно для изменения, то есть не уникально
Собираем воедино: количество различных конфигураций в работе $M$ над $x$ $\leq (n + S(n)) \cdot |Q| \cdot |\Sigma|^{S(n)}$ $= 2^{O(S(n))}$ $\Rightarrow$ $\exists N \in \mathbb{N}\ :$ количество различных конфигураций в работе $M$ над $x$ $\leq 2^N$ (где $N = S(n) \cdot const$).

Заметим, что $M(x) = 1$ $\Leftrightarrow$ финальная конфигурация имеет вид $w_{yes} =$  $x_0q_{yes}x_1\dots x_{n-1}$. При этом начальная конфигурация тоже имеет однозначный вид: $w_{0} =$ $x_0q_{0}x_1\dots x_{n-1}$, то есть нам необходимо построить ДМТ $M'$, которая ищет путь в графе конфигураций $M$ от $w_0$ до $w_{yes}$. Если путь существует, то $x \in A$, иначе $x \not\in A$.

Пусть $R(u, v, k) = 1$ $\Leftrightarrow$ в графе конфигураций $M(x)$ есть путь из $u$ в $v$ длиной не более $2^k$. $M'$ может хранить в памяти отображение на расширенную конфигурацию $M$, тратя $O(1)$, тогда $R(u, v, 0) = 1$ $\Leftrightarrow$ $d_M(u) = v$ - проверяется за $O(S(n))$ доппамяти для записи $u$ и $v$ на ленте. Кроме того, верен следующий факт: $R(u, v, k) = 1$ $\Leftrightarrow$ $\exists w\ :\ R(u, w, k-1) = 1 \wedge R(w, v, k-1) = 1$, что можно проверить так же за $O(S(n))$ доппамяти, перебирая все возможные конфигурации $w$, но записывая их при этом в один и тот же блок памяти (то есть, после проверки конфигурации стираем её и используем те же ячейки для проверки следующей). То есть мы можем использовать рекурсивный алгоритм, который запускает $R(w_{0}, w_{yes}, N)$ - проверку есть ли путь в графе конфигураций от начального состояния до принимающего. Каждая ветка рекурсивного алгоритма имеет глубину $N = O(S(n))$, и при этом на каждом уровне рекурсии вычисление $R$ занимает $O(S(n))$ памяти. Все ветки рекурсии хранить не обязательно: после обработки одной ветки, можно стереть все использованные ячейки, записав только итоговый результат этой ветки. Таким образом, $M'$ занимает не более $O(S^2(n)) = O(s^2(n))$ ячеек памяти, разрешая тот же язык, что и $M$.

### Следствие

- $PSPACE = NPSPACE$

> [!tip] $NP \subseteq PSPACE$
> Если НМТ работает $p(n) = poly(n)$ времени, то она посещает не более $O(p(n))$ ячеек памяти $\Rightarrow$ $NP \subseteq NPSPACE = PSPACE$
