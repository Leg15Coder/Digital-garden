- $GG = \{(G, b)\ |$ первый игрок побеждает в обобщённой игре в города на орграфе $G$ если он выбрал первую вершину $b$ и играет оптимально $\} \in PSPACEC$

> [!info] Правила обобщённой игры в города на графе
> 1) Два игрока по очереди выбирают вершину
> 2) В выбранную вершину можно попасть из предыдущей по одному ребру (первая вершина выбирается произвольно)
> 3) Нельзя выбирать вершину, если ранее она уже была выбрана одним из игроков
> 4) Проигрывает тот, кто не может выбрать вершину в свой код

#### Доказательство

Пусть $Win(v, S, p) = 1$ $\Leftrightarrow$ игрок $p$ выигрывает при оптимальной игре, если сейчас он ходит из вершины $v$ и были посещены уже вершины из множества $S$. Тогда $(G, b) \in GG$ $\Leftrightarrow$ $Win(b, \emptyset, 1) = 1$

Построим детерминированный рекурсивный алгоритм подсчёта функции $Win$:
1) $Win(v, S, p) = 0$, если $\forall u \in V/S\ :\ (v, u) \not\in E$
2) $Win(v, S, p) =$ $\exists u \in V/S\ : (v, u) \in E\ \wedge\ \lnot Win(u, S \cup \{v\}, (p + 1) \% 2 + 1)$

Напишем псевдокод, реализующий $Win$ по описанной выше логике:

```
Win(v, S, p):
	was_win = false
	for u in V:
		if (v, u) in E and not u in S:
			was_win = was_win or Win(u, S and v, (p+1)%2+1
	return was_win
```

- Каждый ход становится на одну доступную для перехода вершину меньше $\Rightarrow$ любая игра длится не более $|V|$ ходов, то есть глубина рекурсии $Win$ не больше $|V|$.
- $S$ мы не будем хранить явно, вместо этого будем пробегаться по стеку рекурсии и искать была ли использована вершина или нет, то есть $S$ занимает $O(0)$ памяти.
- На каждом уровне рекурсии нам надо хранить $v$, $S$, $p$, $u$, и $was\_{win}$, что занимает в сумме $P(\log |V|)$ памяти, следовательно всего памяти тратится не более $O(poly(|G|))$ $\Rightarrow$
$GG \in PSPACE$

Построим сведение $SPACETMSAT \leq_p GG$:
1) Договоримся как 
