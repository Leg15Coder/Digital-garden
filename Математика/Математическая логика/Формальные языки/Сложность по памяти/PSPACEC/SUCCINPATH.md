- $SUCCINPATH = \{(\varphi, s, t)\ |$ в графе, порождённом болевой формулой с чётным количеством переменных $\varphi\ \exists$ путь из вершины $s$ в вершину $t\} \in PSPACEC$

> [!info] Опр.
> Граф $G$ порождён булевой формулой $\varphi$ с переменными $x_1, \dots, x_n, y_1, \dots, y_n$ $\Leftrightarrow$ он содержит $2^n$ вершин, причём в нём есть ребро из $u_i$ в $u_j$ если и только если при представлении $i$ и $j$ в двоичной СС выполняется: $\varphi(bin(i), bin(j)) = 1$. Для краткости будем обозначать: $\varphi(u_i, u_j) = \varphi(bin(i), bin(j))$

#### Доказательство

Пусть $G$ - граф, порождённый болевой формулой $\varphi$ с чётным количеством переменных 

Построим ДМТ $M$, которая разрешает $SUCCINPATH$:
Введём функцию $R(u, v, k) = 1$ $\Leftrightarrow$ в $G$ есть путь из $u$ в $v$ длины не более $2^k$.
1) $\forall u, v \in V\ :\ R(u, v, 0) = 1$ $\Leftrightarrow$ $\varphi(u, v) = 1$ - проверяется за полиномиальную память прямой подстановкой в формулу
2) $R(u, v, k) = 1$ $\Leftrightarrow$ $\exists w\ :\ R(u, w, k-1) \wedge R(w, v, k-1)$ - то есть мы можем вычислить функцию рекурсивно. На каждом уровне рекурсии достаточно хранить $O(\log |V|)$ информации: счётчик по вершинам $w$, которые мы перебираем, а так же значения $u$, $v$ и $k$
3) Глубина рекурсии - $O(\log |V|)$, поскольку максимальная длина кратчайшего пути между вершинами в графе - $|V| - 1$
4) Тогда $M(\varphi, s, t) = R(s, t, \log |V|)$
Итого по памяти: мы храним $O(\log |V|)$ уровней рекурсии, на каждом из которых храним $O(\log |V| + |\varphi|)$ информации, то есть суммарная память $O(\log^2|V| + |\varphi| \log |V|) =$ \[поскольку $|V| = 2^n$, где $2n$ - количество переменных в $\varphi$, то есть $n = O(|\varphi|)$\] $= O(|\varphi|^2)$ $= O(poly(|\varphi|))$ $\Longrightarrow$ $SUCCINPATH \in PSPACE$

Построим сведение $SPACETMSAT \leq_p SUCCINPATH$:
1) Количество различных конфигураций некоторой МТ $M$, которая использует не более $S$ ячеек памяти равно $|\Sigma|^S \cdot S \cdot |Q|$ $= 2^{O(S)}$, то есть $\exists m \in \mathbb{N}\ :$ количество различных конфигураций МТ $M$ $\leq 2^m$, то есть мы можем занумеровать все конфигурации $m$ битами, причём можно выделить конкретные биты под запись положения головки ($O(\log S)$ битов), конкретные биты под запись состояния головки ($O(\log |Q|)$ битов) и для каждой ячейки на ленте выделить $O(\log |\Sigma|)$ конкретных битов для кодирования символа на ней. Добавим к $m$ ещё один бит, который будем использовать чуть позднее в 3-м пункте. Назовём этот бит "специальный". При кодировании всех конфигураций он равен 0.

2) Теперь построим формулу $\varphi(u, v)$, где $u$ и $v$ - наборы из $m$ переменных так, чтобы она порождала граф конфигураций работы $M(x)$ на $s$ ячейках памяти. Будем использовать таблицу переходов $\delta$ МТ $M$: 
	1) По $u$ и по $v$ в силу описанной выше кодировки мы можем однозначно восстановить в соответствующей им по кодировке конфигурации: состояние головки, положение головки, а следовательно и символ под головкой (назовём этот набор $(q, k, a)$)
	2) Добавим через дизъюнкцию в $\varphi$ подформулу, реализующую следующую проверку: $\delta(a_u, q_u) = (a_v, k_v - k_u, q_v)$. Это можно сделать стандартными булевыми операциями, используя при этом $O(u + v)$ памяти (остальная необходимая информация восстанавливается по их кодировке)

3) Теперь добавим в формулу обработку специального бита: число, в котором этот бит равен 1, а остальные бит - 0 обозначим как $t$ - это и будет конечная вершина пути в $SUCCINPATH$. В $\varphi$ добавляем проверку через дизъюнкцию: $(q_u == q_{yes} \wedge v == t)$. Такая проверка будет одна поскольку $q_{yes}$ может быть закодировано только в одном конкретном месте числа.

4) $s$ будет обозначать начальную конфигурацию. Она единственная для конкретного $x$.

Данное сведение работает за полиномиальное время поскольку:
1) Определение кодировки требует $O(|M||s|)$ времени
2) После такой кодировки каждая переменная имеет размер $O(|s|)$, поэтому стандартные операции с переменными в этой кодировке работают за полиномиальное время
3) Количество проверок по $\delta$ не зависит конфигураций, а зависит только от $\delta$: если есть соответствующий переход - мы его добавляем. Если нет - ничего не делаем. Размер $\delta$ зависит от размера $M$, то есть линейно от размера входа, следовательно и добавление всех проверок работает за полином

Таким образом, $SPACETMSAT \leq_p SUCCINPATH$ $\Longrightarrow$ $SUCCINPATH \in PSPACEC$
