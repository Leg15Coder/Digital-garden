==Опр.== **Детерминированный конечный автомат (ДКА)** - одна из частоиспользуемых моделей вычисления. Является совокупностью $<\Sigma, Q, Q_f, \delta, q_0 >$, где
- $\Sigma$ - конечный алфавит
- $Q$ - конечное множество всех состояний ДКА
- $Q_f \subseteq Q$ -  множество принимающих состояний ДКА (если ДКА останавливается в принимающем состоянии, то выводит $q_{yes}$, иначе $q_{no}$)
- $\delta : \Sigma \times Q \rightarrow Q$ - таблица переходов ДКА
- $q_0 \in Q$ - начальное состояние ДКА (при включении ДКА он находится в этом состоянии)

Конечный автомат является частным случаем [[Машина Тьюринга|машины Тьюринга]] и для него распространяются все общие свойства МТ.

Каждый конечный автомат работает ровно $n$ тактов, где $n$ - количество символов во входном слове. ДКА считывает все символы слова последовательно и каждый такт работает с новым символом.

==Опр.== **Полный ДКА (ПДКА)** - ДКА, у которого таблица перехода всюду определена.

- Доопределить ДКА до ПДКА можно добавив непринимающее состояние $q_{\#}$ (которое называется *мусорным* или *трешовым*), которое по всем символам переходит само в себя и все неопределённые ранее переходы идут в это состояние.

### Построение ДКА по [[Недетерминированный конечный автомат|НКА]]

Строить будем явно, то есть предъявим корректный алгоритм построения.
Обозначим всё что связано с НКА без штрихов, а с ДКА - со штрихами (изначально для ДКА все объекты пустые, кроме алфавита - он общий). Пусть $Q_{tmp}$ - вспомогательное множество хранения состояний ДКА. 

Определим операции, которые будем использовать в алгоритме:

1) Эпсилон-замыкание: $C_{\epsilon}(q_0\ (\in Q)) = \{q \in Q\ |\ \exists \{q_i\}_{i=1}^n \subseteq Q\ :\ \begin{cases} q_1 = q_0 \\ q_n = q \\ \forall i \in \overline{2, n}\ :\ \delta(\epsilon, q_{i-1}) = q_i \end{cases}\ \ \}$

2) Мув $move(R\ (\subseteq Q),\ a\ (\in \Sigma \cup \{\epsilon\})) = \{q\ |\ \exists q_{from} \in R\:\ \delta(a, q_{from}) = q\}$

Одному состоянию из ДКА будет соответствовать некоторое множество состояний из НКА. Поэтому мы можем применять к ним определённые выше операции и теоретико-множественные операции и при этом работать как с вершиной.

Сам алгоритм:

1) $q'_0 = \bigcup\limits_{q_0 \in Q_0} C_{\epsilon}(q_0)$
2) $q'_0$ - начальное состояние ДКА, добавим его в $Q_{tmp}$
3) Пока $Q_{tmp}$ не пусто, $\exists R \in Q_{tmp}$
	1) Добавляем $R$ в $Q'$ и удаляем из $Q_{tmp}$
	2) Для каждого $a \in \Sigma$:
		1) Пусть $S = C_{\epsilon}(move(R, a))$
		2) Если $S \neq \emptyset$, $S \not\in Q_{tmp}$ и $S \not\in Q'$, то добавим $S$ в $Q_{tmp}$
		3) $\delta'(a, R) = S$
4) $Q'_f = \{S \in Q'\ |\ S \cap Q_f \neq \emptyset\}$
