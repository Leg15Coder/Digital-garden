### 1. Что такое generics (обобщения)

**Для чего нужны generics?**

Generics (обобщения) — это механизм в Java, который позволяет создавать классы, интерфейсы и методы с параметрами типов. Вместо того чтобы писать отдельный класс для каждого типа данных, можно написать универсальный класс, который работает с любым типом, обеспечивая при этом безопасность типов на этапе компиляции.

Основные задачи generics:

- **Повышение типобезопасности** — ошибки типа при несоответствии типов обнаруживаются при компиляции, а не во время выполнения.
- **Устранение необходимости явных приведений типов (кастов).** Раньше коллекции возвращали `Object`, и приходилось приводить к нужному типу вручную.
- **Повторное использование кода.** Пишем обобщённый класс или метод один раз — используем для разных типов.
- **Повышение читаемости и поддержки кода.** Код с generics проще понять и сопровождать.

---

**В чем разница между `List<String>` и `List<Object>`?**

- `List<String>` — список, который может содержать только строки (`String`). Компилятор гарантирует, что в этот список нельзя положить объекты другого типа, например, `Integer`. При извлечении элементов возвращается тип `String` без явных кастов.
    
- `List<Object>` — список, который может содержать объекты любого типа, так как `Object` — корневой класс. В него можно положить `String`, `Integer`, `Double` и т.д. Но при извлечении элемента придётся приводить его к нужному типу, что опасно и может привести к ошибкам во время выполнения.
    

==Важно понимать, что:==

- `List<String>` **НЕ является** подклассом `List<Object>`. Это связано с тем, что коллекции с generics инвариантны по параметру типа. Например, `List<String>` нельзя присвоить переменной типа `List<Object>`.
    

java

Копировать код

`List<String> strings = new ArrayList<>(); // List<Object> objects = strings; // Ошибка компиляции!`

---

**Что такое wildcards (`?`, `? extends T`, `? super T`)?**

Wildcards — это способ указать в обобщённых типах гибкие параметры с ограничениями, когда точный тип заранее неизвестен или может быть разным.

1. **`?` (неограниченный wildcard)**
    

Обозначает неизвестный тип. Например, `List<?>` — список элементов какого-то неизвестного типа.

Используется, когда метод должен работать с коллекциями любых типов, но не предполагается добавление элементов (потому что нельзя гарантировать безопасность типов).

java

Копировать код

`void printList(List<?> list) {     for (Object obj : list) {         System.out.println(obj);     } }`

2. **`? extends T` (верхняя граница — extends)**
    

Означает: неизвестный тип, который является либо типом `T`, либо его подклассом.

Пример: `List<? extends Number>` — список чисел или их наследников (`Integer`, `Double` и т.д.).

Используется, когда нам нужно **читать** из коллекции объекты типа `T` или его подтипов, но **записывать** туда нельзя (за исключением `null`), чтобы не нарушить типобезопасность.

java

Копировать код

`void processNumbers(List<? extends Number> list) {     for (Number n : list) {         System.out.println(n.doubleValue());     }     // list.add(10); // Ошибка: нельзя добавлять элементы }`

3. **`? super T` (нижняя граница — super)**
    

Означает: неизвестный тип, который является либо типом `T`, либо его суперклассом.

Пример: `List<? super Integer>` — список, в который можно добавлять объекты типа `Integer` и его подклассов, но при чтении из коллекции можно получить только `Object` (потому что неизвестно, какой именно тип в списке).

Используется, когда нам нужно **записывать** объекты типа `T` или его подтипов в коллекцию, но при чтении мы можем получить только верхний тип `Object`.

java

Копировать код

`void addIntegers(List<? super Integer> list) {     list.add(10); // Можно добавлять Integer     // Integer n = list.get(0); // Ошибка компиляции     Object obj = list.get(0); // Можно прочитать как Object }`

---

**Обобщённый совет (PECS):**

- **Producer Extends:** Если коллекция выступает как поставщик данных (только читаем), используйте `? extends T`.
    
- **Consumer Super:** Если коллекция принимает данные (только записываем), используйте `? super T`.
    
- Если и читать, и писать — используйте конкретный параметр типа.
    

---
### 2. Почему нельзя создать массив дженериков (`new T[]`)?

**Причина запрета создания массива обобщённого типа (`new T[]`):**

В Java generics реализованы с помощью **стирания типов (type erasure)**. Это значит, что во время компиляции информация о конкретном параметре типа стирается и заменяется на верхний ограничивающий тип (обычно `Object`), либо на указанный bound.

В результате, в байт-коде и во время выполнения JVM не знает точный параметр типа `T`.

---

При этом массивы в Java — это **ковариантные объекты с проверкой типов во время выполнения** (runtime type checking).

Пример:

java

КопироватьРедактировать

`String[] strings = new String[10]; Object[] objects = strings; // Разрешено, так как массивы ковариантны objects[0] = new Integer(42); // runtime-ошибка ArrayStoreException!`

Это возможно, потому что массив хранит информацию о своём типе элементов во время выполнения и проверяет операции записи.

---

**Конфликт между generics и массивами:**

- С одной стороны, generics стирают тип, и во время выполнения `T` неизвестен.
    
- С другой — массивы требуют знать точный тип элементов во время выполнения для безопасности.
    

Если бы было возможно написать `new T[10]`, то при стирании типов JVM не знала бы, какого именно типа должен быть массив во время исполнения, и безопасность типов была бы нарушена.

Например, с помощью рефлексии можно было бы создать массив `T[]` с неверным элементом — что бы привело к ошибкам.

Поэтому Java запрещает создавать массивы с параметром типа `T` напрямую.

---

### Связь массивов и дженериков

- Массивы в Java — ковариантны, имеют runtime-информацию о типе, проверяют типы при записи.
    
- Generics — инвариантны по типу, типы стираются при компиляции, runtime информации о параметрах типа нет.
    
- Это фундаментальное несоответствие мешает создавать массивы параметризированных типов.
    

---

### Какие есть обходные пути?

1. **Использование массива типа `Object[]` и кастинг:**
    

java

КопироватьРедактировать

`@SuppressWarnings("unchecked") T[] array = (T[]) new Object[size];`

Это самый распространённый способ.

Минусы:

- Требуется подавлять предупреждения компилятора.
    
- Риск `ClassCastException` при неправильном использовании.
    
- Отсутствует runtime-проверка типов для элементов.
    

2. **Передача класса типа `Class<T>` для создания массива через рефлексию:**
    

java

КопироватьРедактировать

`import java.lang.reflect.Array;  public class GenericArray<T> {     private T[] array;      public GenericArray(Class<T> clazz, int size) {         // Создаём массив нужного типа с помощью рефлексии         @SuppressWarnings("unchecked")         T[] tempArray = (T[]) Array.newInstance(clazz, size);         this.array = tempArray;     }      public T get(int index) {         return array[index];     }      public void set(int index, T value) {         array[index] = value;     } }`

Так можно получить типобезопасный массив нужного типа с корректной runtime-информацией.

3. **Использование коллекций вместо массивов:**
    

Обычно, вместо массивов в generic-коде используют `ArrayList<T>`, `LinkedList<T>` и другие коллекции, где тип хранится в компиляционном времени, и при этом можно динамически менять размер.

---

### Итог

- Создание массива типа `T[]` напрямую в Java запрещено из-за особенностей реализации generics (стирания типов) и runtime-проверки типов массивов.
    
- Для обхода используют либо массив `Object[]` с кастингом и подавлением предупреждений, либо создают массив через рефлексию с передачей класса `Class<T>`.
    
- В большинстве случаев рекомендуется заменить массивы коллекциями, которые лучше сочетаются с generics.
    

---

### 3. **Как работает `HashMap`**

`HashMap` — это одна из ключевых реализаций интерфейса `Map` в Java, предназначенная для хранения пар «ключ-значение» с быстрым доступом к элементам по ключу (в среднем `O(1)` для операций `get`, `put`, `remove`).

---

#### 📌 Как устроена `HashMap` внутри

- `HashMap` основан на **массиве корзин** (`Node<K,V>[] table`), каждая корзина содержит либо связанный список, либо сбалансированное дерево (начиная с Java 8).
    
- Ключи хешируются с помощью метода `hashCode()` ключа, а затем вычисляется индекс корзины:
    
    java
    
    КопироватьРедактировать
    
    `int hash = hash(key.hashCode()); int index = (n - 1) & hash;  // n — длина массива, index — место хранения`
    
- Значение помещается в соответствующую корзину (bucket).
    

---

#### 💡 Как разрешаются коллизии в `HashMap`

**Коллизия возникает**, если у разных ключей после вычисления хеша и индекса получается одно и то же место в массиве корзин.

✅ **До Java 8**:

- Коллизии обрабатывались с помощью **связанных списков** в каждой корзине. При добавлении нового элемента он добавляется в начало или конец списка.
    
- При поиске приходится сравнивать `hash` и `equals`, чтобы найти нужный элемент в списке.
    

✅ **Начиная с Java 8**:

- Если количество элементов в корзине превышает порог (по умолчанию `8`), связанный список преобразуется в **красно-чёрное дерево** (self-balancing tree).
    
- Это позволяет улучшить худший случай с `O(n)` до `O(log n)` для поиска по ключу в одной корзине.
    

---

#### ⚠️ Почему важно правильно переопределять `equals()` и `hashCode()` для ключей?

Когда вы используете объект в качестве ключа в `HashMap`, **поиск, вставка и удаление зависят от двух методов ключа**:

1️⃣ `hashCode()`: используется для определения корзины.

2️⃣ `equals()`: используется для проверки равенства ключей внутри одной корзины (если хеши одинаковы).

👉 Если два ключа равны по `equals()`, у них **обязательно должны быть одинаковые `hashCode()`** — это контракт между этими методами.

---

#### Если `hashCode()` и `equals()` реализованы неправильно:

- 🔹 **Нарушение контракта `hashCode()` / `equals()` приводит к багам:**
    
    - `HashMap` может не найти элемент по ключу (например, при вызове `get` вернётся `null` даже если элемент в мапе есть).
        
    - Возможны дубликаты ключей, если разные экземпляры ключа с одинаковыми логическими данными имеют разные хеши.
        
    - Неэффективное распределение по корзинам (все элементы попадают в одну корзину → падение производительности до `O(n)` без преобразования в дерево).
        

---

#### 💡 Пример правильной реализации:

java

КопироватьРедактировать

`public class User {     private String name;     private int age;      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof User)) return false;         User user = (User) o;         return age == user.age && Objects.equals(name, user.name);     }      @Override     public int hashCode() {         return Objects.hash(name, age);     } }`

---

### Итог

✅ **Как работает `HashMap`:**

- Хранит данные в массиве корзин.
    
- Коллизии обрабатываются через связанные списки или деревья.
    
- Доступ к элементам в среднем `O(1)`, при плохом хешировании — хуже.
    

✅ **Коллизии разрешаются:**

- Сначала поиск по хешу.
    
- Затем по `equals` внутри корзины.
    

✅ **Почему важны `equals` и `hashCode`:**

- Для правильного поиска, вставки, удаления элементов.
    
- Для равномерного распределения ключей по корзинам.
    

---

### 4. **HashSet vs LinkedHashSet**

`HashSet` и `LinkedHashSet` — это реализации интерфейса `Set` в Java, которые хранят **уникальные элементы** (без дубликатов). Но между ними есть важные различия в том, как они обеспечивают уникальность и порядок элементов.

---

#### ✅ Как `HashSet` проверяет уникальность элементов?

- В основе `HashSet` лежит **HashMap**. Когда вы добавляете элемент в `HashSet`, он фактически кладётся в `HashMap` как ключ, а значением по умолчанию выступает фиктивный объект (`PRESENT`).
    
- Для проверки уникальности используется комбинация:  
    1️⃣ `hashCode()` — вычисляется хеш-значение элемента, чтобы определить корзину (bucket).  
    2️⃣ `equals()` — если в корзине уже есть элемент с таким хешем, `HashSet` проверяет, равны ли элементы через `equals()`.
    

👉 Если элемент уже есть (по `hashCode` + `equals`), он **не добавляется повторно**.

---

#### ⚠ Почему порядок элементов в `HashSet` не гарантируется?

- `HashSet` не сохраняет информацию о **порядке вставки** элементов.
    
- Порядок зависит от:
    
    - Хеш-кодов элементов.
        
    - Внутреннего распределения по корзинам (которое может меняться при расширении таблицы).
        
- При добавлении или удалении элементов структура корзин может перестроиться (особенно при увеличении capacity), что изменит порядок итерации.
    

👉 Поэтому при итерации по `HashSet` порядок элементов может показаться случайным и не будет соответствовать порядку добавления.

---

#### 🌟 Чем `LinkedHashSet` отличается от `HashSet`?

`LinkedHashSet` — это подкласс `HashSet`, который **сохраняет порядок вставки элементов**.

**Как это достигается?**

- `LinkedHashSet` использует ту же хеш-таблицу, что и `HashSet`.
    
- Но дополнительно каждый элемент связан с предыдущим и следующим элементом через двусвязный список.
    
- Итерация по `LinkedHashSet` всегда возвращает элементы в порядке их добавления.
    

**Ключевые отличия от `HashSet`:**

|`HashSet`|`LinkedHashSet`|
|---|---|
|Не гарантирует порядок элементов при итерации|Гарантирует порядок элементов при итерации (по порядку добавления)|
|Более компактный по памяти|Чуть больше памяти (из-за двусвязного списка)|
|Быстрее при операциях вставки и удаления (нет накладных расходов на связи между элементами)|Чуть медленнее вставка и удаление (из-за поддержки связей)|

---

#### 💡 Когда использовать `HashSet`, а когда `LinkedHashSet`?

|Когда выбрать|Что использовать|
|---|---|
|Если порядок элементов не важен, и нужно минимизировать использование памяти и ускорить операции|`HashSet`|
|Если важен порядок вставки (например, для сериализации, вывода, логов)|`LinkedHashSet`|

---

#### Пример:

java

КопироватьРедактировать

`Set<String> hashSet = new HashSet<>(); hashSet.add("A"); hashSet.add("B"); hashSet.add("C"); System.out.println(hashSet); // Порядок не гарантируется  Set<String> linkedHashSet = new LinkedHashSet<>(); linkedHashSet.add("A"); linkedHashSet.add("B"); linkedHashSet.add("C"); System.out.println(linkedHashSet); // [A, B, C]`

---

### ✉ Итог

✅ `HashSet` проверяет уникальность с помощью `hashCode()` и `equals()`  
✅ `HashSet` не гарантирует порядок элементов, так как он зависит от хеширования и перестроения таблицы  
✅ `LinkedHashSet` обеспечивает сохранение порядка вставки за счёт использования двусвязного списка поверх хеш-таблицы

### 5. **Как происходит работа с многопоточностью в Java**

Многопоточность (multithreading) в Java позволяет программе одновременно выполнять несколько задач, используя возможности многопроцессорных систем и многопоточности на уровне ОС. Java изначально проектировалась с поддержкой многопоточности, что делает работу с потоками относительно удобной.

---

#### 🔹 **Как создать поток (Thread) в Java?**

Существует несколько стандартных способов создания и запуска потоков в Java:

1️⃣ **Через наследование от `Thread`:**

java

КопироватьРедактировать

`class MyThread extends Thread {     @Override     public void run() {         System.out.println("Поток работает");     } }  MyThread t = new MyThread(); t.start(); // запуск нового потока`

➡ Метод `run()` содержит код, который будет выполнен в новом потоке. Метод `start()` создаёт отдельный поток и вызывает `run()`.

---

2️⃣ **Через реализацию интерфейса `Runnable`:**

java

КопироватьРедактировать

`class MyRunnable implements Runnable {     @Override     public void run() {         System.out.println("Поток работает");     } }  Thread t = new Thread(new MyRunnable()); t.start();`

➡ Более гибкий вариант, так как позволяет наследоваться от другого класса (Java не поддерживает множественное наследование классов).

---

3️⃣ **Через `Callable` + `Future`:**

java

КопироватьРедактировать

`ExecutorService executor = Executors.newSingleThreadExecutor(); Future<Integer> future = executor.submit(() -> {     // код потока     return 42; }); Integer result = future.get(); // блокируется до получения результата executor.shutdown();`

➡ `Callable` позволяет возвращать результат и выбрасывать исключения.

---

4️⃣ **Через лямбда-выражение (начиная с Java 8):**

java

КопироватьРедактировать

`Thread t = new Thread(() -> System.out.println("Поток работает")); t.start();`

---

#### 🔹 **Что такое `synchronized` и как он работает?**

`Synchronized` — это ключевое слово в Java, которое используется для организации **мониторной блокировки** (intrinsic lock / monitor lock), чтобы обеспечить потокобезопасный доступ к разделяемым ресурсам.

Когда поток входит в `synchronized`-блок или метод:

- Он захватывает **монитор** (lock) указанного объекта.
    
- Другие потоки блокируются при попытке войти в этот защищённый блок или метод на том же объекте.
    

Когда поток выходит из блока:

- Монитор освобождается.
    
- Один из ожидающих потоков может захватить монитор и продолжить выполнение.
    

**Пример с синхронизированным методом:**

java

КопироватьРедактировать

`public synchronized void increment() {     count++; }`

➡ `synchronized` на нестатическом методе блокирует монитор текущего объекта (`this`).

**Пример с синхронизированным блоком:**

java

КопироватьРедактировать

`public void increment() {     synchronized (this) {         count++;     } }`

**Для статических методов монитором является объект `Class`:**

java

КопироватьРедактировать

`public static synchronized void staticMethod() {     // монитор на объекте Class }`

---

#### 🔹 **Какие есть способы синхронизации потоков?**

В Java есть несколько способов обеспечить синхронизацию и согласованность данных между потоками:

1️⃣ **`synchronized`**

- Методы и блоки (как рассмотрено выше).
    

2️⃣ **Объекты блокировки (`Lock` API)**

- Интерфейс `Lock` (`ReentrantLock`, `ReentrantReadWriteLock` и др.).
    
- Более гибкие возможности (например, попытка захвата с таймаутом, прерывание блокировки).
    

java

КопироватьРедактировать

`Lock lock = new ReentrantLock(); lock.lock(); try {     // критическая секция } finally {     lock.unlock(); }`

---

3️⃣ **Volatile**

- Ключевое слово `volatile` гарантирует, что чтение/запись переменной происходит напрямую из/в память (видимость изменений для других потоков).
    
- Не даёт атомарности операций — только видимость.
    

java

КопироватьРедактировать

`private volatile boolean running = true;`

---

4️⃣ **Классы из пакета `java.util.concurrent`**

- `CountDownLatch`, `Semaphore`, `CyclicBarrier`, `Exchanger` — позволяют координировать потоки.
    
- `ConcurrentHashMap`, `CopyOnWriteArrayList` — потокобезопасные коллекции.
    

---

5️⃣ **Atomic-пакет (`java.util.concurrent.atomic`)**

- Классы вроде `AtomicInteger`, `AtomicLong`.
    
- Предоставляют атомарные операции без явных блокировок.
    

java

КопироватьРедактировать

`AtomicInteger counter = new AtomicInteger(); counter.incrementAndGet();`

---

### ✉ Итог

✅ Потоки можно создавать через `Thread`, `Runnable`, `Callable`, лямбда-выражения и через пул потоков (`ExecutorService`).  
✅ `synchronized` используется для управления доступом к разделяемым ресурсам и блокирует монитор объекта или класса.  
✅ Способы синхронизации потоков: `synchronized`, `Lock`, `volatile`, классы из `java.util.concurrent`, атомарные переменные.

### 6. **Что такое Stream API**

`Stream API` — это инструмент из `java.util.stream`, который появился в Java 8. Он позволяет обрабатывать коллекции (и другие источники данных) декларативно и функционально, используя последовательности элементов и цепочки операций для трансформаций, фильтрации и агрегации данных.

👉 **Главные особенности Stream API:**

- Поддержка ленивых (отложенных) вычислений.
    
- Возможность легко комбинировать операции.
    
- Поддержка параллельных вычислений (через `parallelStream()`).
    
- Код становится короче и выразительнее.
    

---

### 🔹 **Основные операции в Stream API**

Stream API делится на **промежуточные** и **терминальные** операции (об этом ниже). Рассмотрим важнейшие:

#### 1️⃣ `map`

- Преобразует элементы потока с помощью функции.
    
- Возвращает новый поток с преобразованными элементами.
    

java

КопироватьРедактировать

`List<String> names = List.of("Alice", "Bob"); List<Integer> lengths = names.stream()                              .map(String::length)                              .toList();`

➡ Преобразует строки в их длины.

---

#### 2️⃣ `filter`

- Отбирает элементы по условию (предикату).
    

java

КопироватьРедактировать

`List<Integer> nums = List.of(1, 2, 3, 4, 5); List<Integer> even = nums.stream()                          .filter(n -> n % 2 == 0)                          .toList();`

➡ Оставляет только чётные числа.

---

#### 3️⃣ `reduce`

- Агрегирует элементы потока в одно значение.
    
- Например, суммирование:
    

java

КопироватьРедактировать

`int sum = nums.stream()               .reduce(0, Integer::sum);`

➡ Складывает все числа (начиная с 0).

---

### 🔹 **Промежуточные vs терминальные операции**

|Промежуточные операции|Терминальные операции|
|---|---|
|Возвращают новый поток|Завершают обработку потока|
|Ленивые — не выполняются до вызова терминальной операции|Запускают выполнение всей цепочки|
|Например: `map`, `filter`, `sorted`, `distinct`, `limit`|Например: `forEach`, `collect`, `reduce`, `count`, `anyMatch`|

⚠ **Важно:** промежуточные операции строят цепочку, но не делают ничего, пока не вызвана терминальная операция.

---

### 🔹 **Stream API и параллельные потоки**

Stream API позволяет легко переключиться на многопоточную обработку данных:

java

КопироватьРедактировать

`list.parallelStream()     .filter(...)     .map(...)     .collect(Collectors.toList());`

✅ **Как это работает?**

- Поток автоматически разбивается на части (splitting) с помощью `Spliterator`.
    
- Части обрабатываются в нескольких потоках (используется ForkJoinPool).
    
- Операции применяются параллельно, а затем результаты объединяются.
    

⚠ **Важные моменты при параллельной обработке:**

- Не все операции одинаково эффективны в параллельном потоке (например, `sorted()` может быть дорогостоящей).
    
- Не следует использовать внешние изменяемые объекты без синхронизации (например, добавлять в общий список).
    
- Порядок выполнения может отличаться (особенно для `forEach`).
    

---

### ✉ Итог

✅ **Stream API** — мощный инструмент для декларативной обработки данных.  
✅ **`map`, `filter`, `reduce`** — ключевые операции для трансформации, фильтрации и агрегации.  
✅ **Промежуточные операции** строят цепочку, **терминальная операция** запускает вычисление.  
✅ **Параллельные потоки** позволяют обрабатывать данные многопоточно, но требуют осторожности.

### 7️. **Что такое аннотации в Java, как создать собственную**

Аннотации в Java — это специальные метаданные, которые можно прикреплять к коду (классам, методам, полям и т. д.) для передачи дополнительной информации компилятору, инструментам или во время выполнения через Reflection API.

Аннотации **не влияют на поведение кода напрямую**, но могут использоваться:

- для проверки кода на этапе компиляции,
    
- для генерации кода (например, Lombok),
    
- для конфигурации фреймворков (например, Spring, JPA).
    

---

#### 🔹 **Примеры стандартных аннотаций**

Java содержит множество встроенных аннотаций. Вот несколько часто используемых:

- `@Override` — сообщает компилятору, что метод переопределяет метод суперкласса:
    

java

КопироватьРедактировать

`@Override public String toString() { ... }`

➡ Компилятор проверит наличие метода в суперклассе и выдаст ошибку при несоответствии.

---

- `@Deprecated` — помечает метод или класс как устаревший:
    

java

КопироватьРедактировать

`@Deprecated public void oldMethod() { ... }`

➡ Компилятор предупредит, если этот метод будет использоваться.

---

- `@SuppressWarnings` — подавляет предупреждения компилятора:
    

java

КопироватьРедактировать

`@SuppressWarnings("unchecked")`

---

- `@FunctionalInterface` — указывает, что интерфейс является функциональным (имеет ровно один абстрактный метод):
    

java

КопироватьРедактировать

`@FunctionalInterface interface MyFunc {     void doWork(); }`

---

#### 🔹 **Как создать собственную аннотацию**

Создать аннотацию можно с помощью ключевого слова `@interface`:

```java
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME) // аннотация доступна в рантайме @Target(ElementType.METHOD)         // можно применять к методам public @interface MyAnnotation {
	String value();     
	int count() default 1;          // параметр со значением по умолчанию 
}
```

➡ Основные мета-аннотации:

- `@Retention` — где аннотация будет доступна (SOURCE, CLASS, RUNTIME)
    
- `@Target` — к чему можно применять (METHOD, FIELD, TYPE и др.)
    
- `@Documented` — включать ли аннотацию в JavaDoc
    
- `@Inherited` — наследуется ли аннотация подклассами
    

---

#### 🔹 **Пример использования собственной аннотации**

```java
public class TestClass {
	@MyAnnotation(value = "Пример", count = 5)     
	public void myMethod() { } 
}
```

---

#### 🔹 **Как обрабатывать аннотации с помощью Reflection API**

Аннотации, у которых `@Retention(RUNTIME)`, можно читать через рефлексию:

`import java.lang.reflect.Method;  public class Main {     public static void main(String[] args) throws Exception {         Method method = TestClass.class.getMethod("myMethod");                  if (method.isAnnotationPresent(MyAnnotation.class)) {             MyAnnotation annotation = method.getAnnotation(MyAnnotation.class);                          System.out.println("value = " + annotation.value());             System.out.println("count = " + annotation.count());         }     } }`

➡ Этот код получит аннотацию `MyAnnotation` у метода `myMethod` и выведет её параметры.

---

### ✉ Итог

✅ Аннотации в Java используются для добавления метаданных и инструкций компилятору или инструментам.  
✅ Стандартные аннотации помогают компилятору и читающему код (например, `@Override`, `@Deprecated`).  
✅ Свои аннотации можно создавать с помощью `@interface`, задавая параметры, область применения и жизненный цикл.  
✅ Обработка аннотаций осуществляется через Reflection API.

### 8️. **Что такое Records**

`Record` — это специальный тип класса, введённый в **Java 14** как preview feature и окончательно добавленный в **Java 16**.  
Records предназначены для **иммутабельных структур данных**, которые хранят только данные без сложной логики.

👉 **Ключевая идея Records:**  
Сократить шаблонный код (boilerplate) для классов, которые просто являются "контейнерами данных" — например, DTO, Value Objects.

---

### 🔹 **Чем Records отличаются от обычных классов?**

|Обычный класс|Record|
|---|---|
|Нужно явно писать конструктор, `get`-методы, `equals`, `hashCode`, `toString`|Эти методы автоматически генерируются|
|Можно делать поля изменяемыми|Поля `record` всегда `final` и `private`|
|Можно наследоваться от другого класса|Record **не может наследоваться** от класса (кроме `java.lang.Record`)|
|Можно расширять иерархии классов|Record — всегда финальный (нельзя от него наследоваться)|

✅ Record автоматически создаёт:

- приватные финальные поля;
    
- конструктор с параметрами для всех компонентов;
    
- геттеры (методы без префикса `get`);
    
- `equals()`, `hashCode()`, `toString()`.
    

---

### 🔹 **Какие методы автоматически генерируются для Records?**

Для записи вида:

java

КопироватьРедактировать

`public record Person(String name, int age) {}`

компилятор создаёт:

java

КопироватьРедактировать

`// Приватные final поля: private final String name; private final int age;  // Публичный конструктор: public Person(String name, int age) {     this.name = name;     this.age = age; }  // Геттеры: public String name() { return name; } public int age() { return age; }  // equals(), hashCode(), toString(): // - equals сравнивает значения всех полей // - hashCode считает хеш на основе всех полей // - toString возвращает строку вроде: Person[name=Alice, age=30]`

⚠ **Важно:** методы `name()` и `age()` — это геттеры, но без префикса `get`.

---

### 🔹 **В каких случаях удобно использовать Records?**

✅ Когда нужен **контейнер данных без логики**, например:

- DTO (Data Transfer Object) между слоями приложения.
    
- Ключи и значения для коллекций.
    
- Конфигурационные параметры (например, в тестах).
    
- Простые иммутабельные сущности, не требующие наследования.
    

Пример:

java

КопироватьРедактировать

`public record Point(int x, int y) {}`

Это полностью готовый класс для представления точки с двумя координатами — без лишнего кода.

---

### 🔹 Ограничения Records

⚠ **Record не подходит**, если:

- требуется изменяемое состояние (нет сеттеров);
    
- нужно наследовать поведение (record — final);
    
- нужны дополнительные поля, которых нет в заголовке record.
    

---

### ✉ Итог

✅ **Records** — это лаконичный способ описания неизменяемых классов-«контейнеров данных».  
✅ Компилятор сам создаёт конструктор, геттеры, `equals`, `hashCode`, `toString`.  
✅ Используются, когда важны только данные, а не логика или иерархия классов.

### 9️. **Устройство памяти в JVM: области и их ответственность**

Виртуальная машина Java (JVM) управляет памятью в процессе выполнения программы, разделяя её на несколько областей, каждая из которых выполняет свою функцию. Эти области создаются при запуске JVM и используются для хранения различных типов данных.

---

#### 🔹 **Основные области памяти JVM**

1️⃣ **Heap (куча)**

- Это основная область памяти для хранения объектов и массивов.
    
- Heap делится на **молодое поколение (Young Generation)** и **старое поколение (Old Generation)**.
    
- **Young Generation**: объекты, которые создаются недавно (короткоживущие объекты).
    
- **Old Generation**: объекты, которые пережили несколько сборок мусора и считаются долгоживущими.
    
- Управляется сборщиком мусора (Garbage Collector).
    

👉 **Назначение Heap:**  
Хранение всех объектов и массивов данных, создаваемых в процессе работы приложения.

---

2️⃣ **Stack (стек потоков)**

- Каждому потоку создаётся свой стек при запуске.
    
- Хранит **фреймы вызова методов** (Call Stack).
    
- В каждом фрейме: локальные переменные, параметры метода, ссылки на объекты в куче, данные для промежуточных вычислений.
    

👉 **Назначение Stack:**  
Обеспечивает управление вызовами методов и хранение их локального состояния.  
⚠ Область памяти стека ограничена, и переполнение стека вызывает `StackOverflowError`.

---

3️⃣ **Method Area (или Metaspace начиная с Java 8)**

- Хранит **структуры классов**, такие как:
    
    - байткод методов,
        
    - константные пулы,
        
    - информацию о полях и методах,
        
    - аннотации, метаданные.
        
- Начиная с Java 8, вместо PermGen используется **Metaspace**, которая выделяется из нативной памяти и автоматически растёт при необходимости (в отличие от фиксированного PermGen).
    

👉 **Назначение Method Area:**  
Хранение метаданных классов, используемых JVM при выполнении программы.

---

4️⃣ **PC Register (Program Counter)**

- Для каждого потока хранит адрес текущей выполняемой инструкции.
    

---

5️⃣ **Native Method Stack**

- Обслуживает вызовы нативных (не-Java) методов, например написанных на C/C++.
    

---

#### 🔹 **Чем отличается Heap от Stack?**

|Heap|Stack|
|---|---|
|Общая область памяти для всех потоков|У каждого потока свой стек|
|Хранит объекты и массивы|Хранит локальные переменные, параметры методов, ссылки на объекты|
|Управляется сборщиком мусора|Автоматически освобождается при завершении метода|
|Медленнее по доступу (больше накладных расходов на управление памятью)|Быстрее по доступу (работа с фреймами вызова методов)|
|Объекты живут до тех пор, пока на них есть ссылки|Данные живут, пока выполняется метод|

---

#### 🔹 **Какие объекты хранятся в Heap, а какие в Stack?**

✅ **Heap:**

- Все объекты, созданные с помощью `new` (включая массивы).
    
- Объекты классов, лямбда-выражения (объекты функциональных интерфейсов).
    
- Объекты, на которые ссылаются локальные переменные стека.
    

✅ **Stack:**

- Примитивные типы данных (например `int`, `double`), если они объявлены как локальные переменные в методе.
    
- Ссылки на объекты (сами объекты находятся в куче).
    
- Параметры методов при вызове.
    

---

#### ✉ **Итог**

✅ Память в JVM делится на Heap, Stack, Method Area (Metaspace) и другие области, каждая из которых выполняет свою роль.  
✅ Heap предназначен для хранения объектов и управляется сборщиком мусора.  
✅ Stack хранит контекст вызова методов и локальные данные потока.  
✅ Метод Area / Metaspace хранит структуру классов и метаданные.

### 10. **Устройство Garbage Collection в JVM: задачи, виды, как работает**

---

#### 🔹 **Задачи Garbage Collector (GC)**

Garbage Collector (GC) в JVM — это автоматический механизм управления памятью.  
Его основная цель:  
✅ Освобождать память, занимаемую объектами, которые больше не используются (на них нет ссылок).  
✅ Избегать утечек памяти (memory leaks).  
✅ Уменьшать накладные расходы на управление памятью для разработчика.

⚠ Важно: разработчик не управляет сборкой мусора напрямую, а только может подсказывать GC (например, вызовом `System.gc()` — но это лишь рекомендация).

---

#### 🔹 **Как работает Garbage Collection в Java?**

➡ JVM отслеживает объекты в Heap и проверяет, достижимы ли они из _корневых ссылок_ (GC Roots).  
➡ Если на объект нет ни одной цепочки ссылок от GC Roots, он считается _неживым_ и подлежит удалению.

👉 **GC Roots** — это:

- активные потоки,
    
- локальные переменные на стеке,
    
- классы и их статические поля,
    
- ссылки из нативного кода.
    

➡ Сборщик мусора проходит по графу объектов, начиная с GC Roots, и помечает достижимые объекты.  
➡ После этого удаляются все недостижимые объекты, освобождая память.

---

#### 🔹 **Этапы сборки мусора (Minor GC, Major GC, Full GC)**

В большинстве современных реализаций JVM (например, HotSpot) используется _поколенческая сборка мусора_. Heap делится на поколения, и GC работает с ними по-разному:

|Тип GC|Что очищает|Когда срабатывает|Характеристика|
|---|---|---|---|
|**Minor GC**|Только _Young Generation_ (молодое поколение)|Когда молодое поколение заполняется|Быстрая сборка, короткая пауза|
|**Major GC** (или Old GC)|_Old Generation_ (старое поколение)|Когда старое поколение заполняется|Более дорогая по времени|
|**Full GC**|Очищает _всю кучу_ (Young + Old + Metaspace)|Когда нужно полностью освободить память или при критическом недостатке памяти|Самая дорогая, вызывает стоп мира (stop-the-world)|

👉 **Stop-the-world** — момент, когда выполнение всех потоков приложения приостанавливается для работы GC.

---

#### 🔹 **Что такое Generational GC и как он работает?**

✅ **Generational Garbage Collection** (поколенческая сборка мусора) — это стратегия, основанная на наблюдении:  
📌 Большинство объектов в Java "умирают молодыми" (живут недолго).

Heap делится на:

- **Young Generation (Eden + Survivor Spaces)** — здесь создаются новые объекты.
    
- **Old Generation (Tenured)** — сюда перемещаются объекты, которые пережили несколько циклов Minor GC.
    

👉 **Как это работает?**  
1️⃣ Новый объект создаётся в **Eden Space** (Young Generation).  
2️⃣ Когда Eden заполняется, запускается **Minor GC**:

- живые объекты перемещаются в Survivor Space (или сразу в Old Generation, если они "достаточно стары").
    
- память Eden очищается.  
    3️⃣ Объекты, которые переживают несколько Minor GC (обычно определяется специальным счётчиком "age"), перемещаются в **Old Generation**.  
    4️⃣ Когда Old Generation заполняется, запускается **Major GC / Full GC** для очистки старого поколения.
    

---

#### 🔹 **Дополнительно о современных сборщиках мусора**

💡 В разных версиях JVM доступны разные сборщики мусора:

- **Serial GC** — однопоточный, простейший.
    
- **Parallel GC** — многопоточный сборщик для серверных приложений.
    
- **CMS (Concurrent Mark-Sweep)** — минимизирует паузы за счёт параллельной работы с приложением (устарел в новых версиях).
    
- **G1 GC (Garbage First)** — современный сборщик для больших heap, управляет памятью блоками (region-based), минимизирует паузы.
    
- **ZGC, Shenandoah** — низкопаузные сборщики в новых версиях JVM.
    

---

#### ✉ **Итог**

📌 Garbage Collector в JVM автоматически освобождает память от ненужных объектов.  
📌 Поколенческая модель позволяет эффективно управлять памятью с учётом жизненного цикла объектов.  
📌 Minor GC — для короткоживущих объектов, Major/Full GC — для долгоживущих.  
📌 Настройка GC и выбор подходящего сборщика важны для производительности крупных приложений.

### 1️1. **Что такое JIT-компиляция**
#### 🔹 **Что такое JIT-компиляция?**

JIT (Just-In-Time) компиляция — это технология в JVM, которая _динамически_ компилирует байткод в машинный код во время выполнения программы.  
👉 Цель JIT — ускорить выполнение, превращая часто используемый байткод в высокоэффективный машинный код для конкретной архитектуры процессора.

➡ JIT-компилятор встроен в JVM и работает параллельно с интерпретатором.

---

#### 🔹 **Как JIT-компилятор ускоряет выполнение Java-кода?**

✅ При запуске программы байткод сначала интерпретируется (выполняется построчно).  
✅ JVM следит за тем, какие методы/участки кода вызываются часто (так называемые _горячие участки_, hot spots).  
✅ Когда метод или участок кода становится _горячим_, JIT-компилятор компилирует его в машинный код.  
✅ В дальнейшем JVM напрямую исполняет уже скомпилированный машинный код вместо интерпретации байткода.

📌 **Оптимизации JIT-компилятора:**

- **Inlining** — подстановка тел методов прямо в вызовы (устранение накладных расходов на вызов метода).
    
- **Loop unrolling** — разворачивание циклов для сокращения числа итераций.
    
- **Elimination of dead code** — удаление кода, который не влияет на результат.
    
- **Escape analysis** — анализ области видимости объектов, чтобы размещать их в стеке, а не в куче.
    

➡ Эти оптимизации позволяют программе работать почти с той же скоростью, что и код на C/C++.

---

#### 🔹 **Чем интерпретатор отличается от JIT-компилятора?**

|Интерпретатор|JIT-компилятор|
|---|---|
|Выполняет байткод строчка за строчкой|Компилирует часто используемый байткод в машинный код|
|Быстрее запускается (не тратит время на компиляцию)|Быстрее работает после разгона (оптимизация горячих участков)|
|Не генерирует машинный код|Генерирует машинный код и кэширует его|
|Не выполняет сложных оптимизаций|Выполняет глубокие оптимизации для ускорения работы|

👉 Обычно JVM сначала интерпретирует байткод, а затем JIT компилирует горячие участки.

---

#### 🔹 **Какова единица компиляции в JIT-компиляторе?**

✅ **Единица компиляции в JIT-компиляторе JVM — это метод.**  
JIT компилирует целый метод в машинный код.

- JVM отслеживает количество вызовов метода или число выполненных циклов в методе.
    
- После достижения порогового значения (например, 10 000 вызовов) метод считается горячим и компилируется JIT.
    

---

#### ✉ **Итог**

📌 JIT-компиляция — ключевой элемент производительности JVM, превращающий интерпретируемый байткод в нативный машинный код.  
📌 Интерпретатор обеспечивает быстрое начало работы программы, а JIT — её высокую скорость при длительном выполнении.  
📌 JIT-компилятор работает на уровне методов, анализируя их вызовы и оптимизируя исполнение.

### 1️2. **Что такое Unit и интеграционные тесты**

---

#### 🔹 **Какие задачи решают Unit-тесты?**

✅ **Unit-тесты** (модульные тесты) предназначены для проверки работы _отдельных компонентов программы_ (например, одного метода, функции, класса) изолированно от остальной системы.

Основные задачи Unit-тестов:

- Проверять корректность работы отдельного модуля на заранее известных входных данных.
    
- Служить документацией — показывать, как предполагается использовать модуль.
    
- Обеспечивать быструю обратную связь при изменениях в коде (регрессионное тестирование).
    
- Упрощать рефакторинг: если тесты покрывают код, можно безопаснее его изменять.
    

⚠ **Важно:** в Unit-тестах внешние зависимости (например, база данных, файлы, сеть) подменяются с помощью моков, стабов или фейков.

---

#### 🔹 **Почему важно разделять Unit-тесты и интеграционные тесты?**

✅ **Интеграционные тесты** проверяют работу нескольких модулей в связке, а также взаимодействие с внешними системами: БД, файловой системой, REST API, брокерами сообщений и т.д.

📌 Почему важно разделять:

- **Скорость:** Unit-тесты быстрые (миллисекунды), интеграционные тесты медленные (секунды, минуты).
    
- **Цель проверки:** Unit-тест проверяет логику модуля, интеграционный — взаимодействие между модулями или системами.
    
- **Изоляция:** Unit-тест должен быть независимым от окружения; интеграционный — зависит от реального или эмулированного окружения (например, Testcontainers).
    
- **Стабильность:** Unit-тесты меньше подвержены флейкам (ложным срабатываниям), интеграционные — более чувствительны к проблемам инфраструктуры.
    

💡 **Хорошая практика:**

- Отдельные директории или теги для разных видов тестов (например, `src/test/java/unit/...` и `src/test/java/integration/...`).
    
- Отдельные запускатели (maven-surefire для unit, maven-failsafe для integration).
    

---

#### 🔹 **Какой фреймворк используется для написания Unit-тестов в Java?**

✅ Наиболее распространённый фреймворк для Unit-тестов в Java:

- **JUnit (JUnit 5 / Jupiter)** — де-факто стандарт для написания модульных тестов.
    
    - Аннотации: `@Test`, `@BeforeEach`, `@AfterEach`, `@BeforeAll`, `@AfterAll`
        
    - Возможности: параметризованные тесты, условия выполнения (`@EnabledIf...`), теги (`@Tag`).
        

✅ Дополнительно часто используются:

- **Mockito / EasyMock / JMockit** — для создания моков и стабов зависимостей.
    
- **AssertJ / Hamcrest** — для удобных fluent-assertions.
    

---

#### ✉ **Итог**

|Unit-тест|Интеграционный тест|
|---|---|
|Проверяет один модуль в изоляции|Проверяет взаимодействие модулей/систем|
|Быстрый, не зависит от окружения|Медленный, зависит от внешних систем|
|Использует моки|Работает с реальными зависимостями или их имитацией|
|JUnit + Mockito|JUnit + Testcontainers / реальная инфраструктура|

---

### 1️3️. **Что такое E2E тестирование**
#### 🔹 **Что такое E2E тестирование?**

**E2E (End-to-End)** тестирование — это вид тестирования, при котором проверяется полное приложение или система «от начала до конца».  
✅ Цель: убедиться, что все слои системы правильно взаимодействуют друг с другом и что бизнес-функционал выполняется корректно в условиях, максимально приближённых к реальному использованию.

E2E-тест имитирует сценарии из жизни пользователя:

- Пользователь заполняет форму → данные передаются на сервер → сохраняются в БД → отправляется уведомление.
    
- Сервис обрабатывает запрос через фронт, бэкенд, очередь сообщений, БД и внешний API.
    

---

#### 🔹 **Чем E2E тестирование отличается от модульного и интеграционного?**

|Вид теста|Что проверяет|Изоляция|Скорость|Зависимости|
|---|---|---|---|---|
|**Unit-тест**|Логику отдельного метода или класса|Полная изоляция|Очень высокая|Нет внешних|
|**Интеграционный тест**|Взаимодействие нескольких компонентов/модулей|Частичная|Средняя|Поднятые БД, очереди и т.д.|
|**E2E тест**|Работу всего приложения целиком|Нет|Медленная|Реальная инфраструктура|

💡 **Главные отличия E2E**:

- Тестируется вся цепочка от UI или внешнего интерфейса до БД и обратно.
    
- Задействованы реальные или близкие к реальным окружения (например, тестовые сервера, базы данных, очереди сообщений).
    

---

#### 🔹 **Какие слои приложения охватывает E2E тестирование?**

E2E-тестирование включает в себя:  
✅ **Frontend (UI)** — работа интерфейса, формы, кнопки, события.  
✅ **Backend (API, сервисы)** — обработка запросов, бизнес-логика.  
✅ **Базы данных** — сохранение, изменение, удаление данных.  
✅ **Интеграция с внешними сервисами** — API других систем, платежные шлюзы, уведомления.  
✅ **Сообщения, очереди, брокеры** — Kafka, RabbitMQ, и т.п.

👉 Другими словами, E2E-тест захватывает полный жизненный цикл запроса от ввода пользователем до изменения состояния системы.

---

#### 🔹 **Почему E2E тесты считаются наиболее приближенными к реальным условиям?**

✅ **Причины:**

- E2E тесты моделируют реальные сценарии использования (как пользователь или другая система взаимодействует с приложением).
    
- Они проверяют _всю систему в сборе_ — не отдельные куски, а то, как эти куски работают вместе.
    
- Используют реальные данные или их копии и настоящую инфраструктуру (или её эмуляцию максимально близкую к боевой).
    

⚠ Минус E2E-тестов:

- Медленные в запуске и выполнении.
    
- Дорого стоят в поддержке.
    
- Более подвержены флейкам (нестабильным сбоям из-за проблем в инфраструктуре).
    

---

#### ✉ **Итог**

📌 **E2E-тестирование** — это проверка полной работы системы в условиях, близких к эксплуатации.  
📌 Оно дополняет Unit и интеграционные тесты, но не заменяет их, так как работает на другом уровне проверки.  
📌 Важно, чтобы E2E-тестов было не слишком много (по пирамиде тестирования: их доля должна быть небольшой).

### 1️4️. **Что такое потокобезопасность и как ее достичь**
#### 🔹 **Что такое потокобезопасность?**

**Потокобезопасность (thread safety)** — это свойство программы или объекта корректно работать при одновременном доступе из нескольких потоков без возникновения некорректных состояний или ошибок.

- Если объект потокобезопасен, то его методы можно вызывать одновременно из разных потоков без дополнительной синхронизации.
    
- Если нет — возможны гонки данных (data races), состояния гонки (race conditions), неконсистентность данных, ошибки и даже крахи.
    

---

#### 🔹 **Какие классы в Java являются потокобезопасными по умолчанию?**

В стандартной Java есть разные категории классов по потокобезопасности:

1. **Immutable классы** — объекты которых нельзя изменить после создания. Они по определению потокобезопасны, например:
    
    - `String`
        
    - Все классы обертки над примитивами (`Integer`, `Long`, `Double` и т.п.)
        
    - Классы из `java.time` (например, `LocalDate`, `Instant`)
        
2. **Классы из пакета java.util.concurrent** — специально разработаны для безопасной работы в многопоточной среде:
    
    - `ConcurrentHashMap`
        
    - `CopyOnWriteArrayList`
        
    - `BlockingQueue` и его реализации (`ArrayBlockingQueue`, `LinkedBlockingQueue`)
        
    - `AtomicInteger`, `AtomicReference` и другие атомарные классы
        
3. **Синхронизированные обертки из Collections**:
    
    - `Collections.synchronizedList(...)`, `Collections.synchronizedMap(...)` и т.д.
        
4. **Некоторые классы, внутренне синхронизированные** (но часто устаревшие, не рекомендуется использовать):
    
    - `Vector`
        
    - `Hashtable`
        

---

#### 🔹 **Почему классы без состояния (stateless) всегда потокобезопасны?**

✅ **Stateless** означает, что объект **не хранит внутреннего изменяемого состояния**, от которого зависит логика.

- Все вызовы методов такого объекта **не зависят от изменений внутреннего состояния**.
    
- Методы могут выполнять только операции, зависящие от параметров и локальных переменных — а локальные переменные живут в стеке каждого потока и не разделяются.
    
- Следовательно, отсутствует возможность возникновения гонок данных.
    

Пример stateless объекта — класс с утилитными статическими методами (`Math`, например) или сервис, который принимает данные, обрабатывает и возвращает результат, не сохраняя промежуточных состояний.

---

#### 🔹 **Как достичь потокобезопасности?**

Основные способы сделать класс потокобезопасным:

1. **Иммутабельность**
    
    - Создавать объекты с неизменяемым состоянием.
        
    - Все поля — `final`, состояние не меняется после конструктора.
        
2. **Синхронизация**
    
    - Использование ключевого слова `synchronized` для методов или блоков.
        
    - Использование `Lock` (например, `ReentrantLock`) из `java.util.concurrent.locks`.
        
3. **Использование атомарных операций**
    
    - Классы из пакета `java.util.concurrent.atomic`, например `AtomicInteger`.
        
4. **Использование потокобезопасных коллекций**
    
    - `ConcurrentHashMap`, `CopyOnWriteArrayList` и пр.
        
5. **Использование локальных переменных**
    
    - Локальные переменные живут в стеке, каждый поток имеет свой стек — поэтому они по умолчанию потокобезопасны.
        
6. **Избегать разделяемого изменяемого состояния**
    

---

#### ✉ **Итог**

|Категория|Потокобезопасность|Пример|
|---|---|---|
|Immutable классы|Всегда безопасны|`String`, `Integer`|
|Stateless объекты|Всегда безопасны|Утилитные классы|
|Синхронизированные коллекции|Да|`Collections.synchronizedList`|
|Concurrent коллекции|Да|`ConcurrentHashMap`|
|Обычные изменяемые объекты|Нет без синхронизации|`ArrayList`, обычные POJO|

---

### 1️5️. **Проблема Race Condition**
#### 🔹 **Что такое race condition (состояние гонки)?**

Race condition — это ситуация в многопоточной программе, когда несколько потоков одновременно обращаются к одним и тем же данным или ресурсам, причем как минимум один из них пытается их изменить, и итоговое состояние зависит от порядка выполнения операций.

⚠️ Если управление потоками и доступ к разделяемым ресурсам не синхронизированы, это может привести к **некорректным результатам, потерям данных, ошибкам логики или аварийному завершению программы**.

---

#### 🔹 **Как race condition влияет на программу?**

- Нарушается целостность данных.
    
- Итоговый результат зависит от непредсказуемого порядка выполнения.
    
- Ошибки трудно отловить и воспроизвести, они могут проявляться случайно.
    
- Программа становится нестабильной и непредсказуемой.
    

---

#### 🔹 **Пример race condition**

Рассмотрим простой класс-счетчик:

java

КопироватьРедактировать

`public class Counter {     private int count = 0;      public void increment() {         count = count + 1;     }      public int getCount() {         return count;     } }`

Если несколько потоков вызывают `increment()` одновременно, происходит race condition:

- Поток A читает значение `count` (например, 5).
    
- Поток B читает тоже 5.
    
- Поток A прибавляет 1 и записывает 6.
    
- Поток B прибавляет 1 и тоже записывает 6.
    

Ожидается, что после двух вызовов `increment()` будет 7, а получается 6 — одна операция потерялась.

---

#### 🔹 **Как исправить race condition?**

1. **Синхронизация методов**
    

java

КопироватьРедактировать

`public synchronized void increment() {     count = count + 1; }`

Теперь одновременно выполнять метод смогут только один поток, другие будут ждать.

2. **Использование атомарных классов**
    

java

КопироватьРедактировать

`import java.util.concurrent.atomic.AtomicInteger;  public class Counter {     private AtomicInteger count = new AtomicInteger(0);      public void increment() {         count.incrementAndGet();     }      public int getCount() {         return count.get();     } }`

Атомарные операции гарантируют корректный инкремент без блокировок.

3. **Использование блокировок**
    

java

КопироватьРедактировать

`import java.util.concurrent.locks.ReentrantLock;  public class Counter {     private int count = 0;     private final ReentrantLock lock = new ReentrantLock();      public void increment() {         lock.lock();         try {             count++;         } finally {             lock.unlock();         }     } }`

---

#### ✉ **Итог**

- Race condition — опасная проблема в многопоточном программировании.
    
- Возникает при неконтролируемом совместном доступе к разделяемым данным.
    
- Исправляется использованием синхронизации, атомарных операций или других механизмов защиты состояния.

### 1️6️. **Ключевое слово `volatile`**
#### 🔹 **Что такое `volatile`?**

`volatile` — это модификатор переменной в Java, который гарантирует **видимость изменений этой переменной во всех потоках**. Это означает, что если один поток изменил значение `volatile`-переменной, другой поток, читающий эту переменную, сразу увидит обновленное значение.

---

#### 🔹 **Когда следует использовать `volatile`?**

- Когда переменная может читаться и записываться из разных потоков.
    
- Если нужна гарантия, что **последнее записанное значение переменной будет видимо другим потокам сразу**.
    
- Для флагов состояния, индикаторов завершения, сигналов остановки и прочих «сигнальных» переменных, где нет сложных операций изменения — только простая запись и чтение.
    

---

#### 🔹 **Проблемы, которые решает `volatile`**

- Устраняет проблему **кэширования переменной в регистрах или локальных кэших процессора** — данные всегда берутся из основной памяти.
    
- Гарантирует порядок записи и чтения (эффект happens-before) для самой переменной: изменения одного потока будут видны другим потокам.
    

---

#### 🔹 **Почему `volatile` не решает проблему атомарности?**

`volatile` **не делает операции с переменной атомарными**. Он только гарантирует видимость изменений.

Пример:

java

КопироватьРедактировать

`volatile int count = 0;  void increment() {     count = count + 1; // НЕ атомарно }`

Операция `count = count + 1` — это три шага:

1. Прочитать текущее значение.
    
2. Добавить 1.
    
3. Записать результат обратно.
    

Если два потока выполняют это одновременно, возможен race condition, несмотря на `volatile`.

Для атомарных операций нужно использовать:

- Синхронизацию (`synchronized`).
    
- Атомарные классы из `java.util.concurrent.atomic` (например, `AtomicInteger`).
    

---

#### 🔹 **Когда `volatile` достаточно, а когда нет?**

- **Достаточно**: для простых флагов или сигналов (например, `volatile boolean running`), когда надо только считать/писать без сложных вычислений.
    
- **Недостаточно**: для счетчиков, накопителей, операций сложного обновления или когда нужно обеспечить комплексные атомарные изменения. Тогда нужны блокировки или атомарные классы.
    

---

#### 🔹 **Итог**

- `volatile` гарантирует **видимость изменений переменной между потоками**.
    
- Не гарантирует **атомарность** сложных операций.
    
- Используется для простых случаев — флаги, сигналы.
    
- Для сложных операций нужен `synchronized` или атомарные структуры.

### 1️7️. **Ключевое слово `synchronized`**
#### 🔹 **Как работает `synchronized`?**

`Synchronized` — это механизм в Java для организации **взаимного исключения (mutual exclusion)** между потоками, чтобы гарантировать, что только один поток в один момент времени может выполнять защищённый блок кода или метод.

- При входе в синхронизированный блок или метод поток **захватывает монитор** (lock) объекта-монитора.
    
- Если монитор занят другим потоком, текущий поток **блокируется и ждет**, пока монитор не освободится.
    
- После выхода из синхронизированного блока монитор освобождается, и следующий ожидающий поток может войти.
    

Это гарантирует, что операции над общими ресурсами выполняются **атомарно** и без одновременного доступа.

---

#### 🔹 **Какие объекты могут быть монитором?**

В Java в качестве монитора можно использовать **любой объект** (`java.lang.Object`). Это значит, что синхронизация всегда связана с конкретным объектом:

- В случае синхронизированного нестатического метода монитором является **текущий объект (`this`)**.
    
- В случае синхронизированного статического метода монитором является **объект класса (`Class` объект)**.
    
- В синхронизированном блоке вы можете указать любой объект:
    

java

КопироватьРедактировать

`synchronized(someObject) {     // критическая секция }`

Этот объект выступает как «замок» для критической секции.

---

#### 🔹 **Разница между синхронизированным методом и синхронизированным блоком**

|Характеристика|Синхронизированный метод|Синхронизированный блок|
|---|---|---|
|Область синхронизации|Весь метод|Часть метода (локальный блок кода)|
|Монитор|`this` (для нестатического метода) или `Class` (для статического)|Явно указанный объект, например `synchronized(lock)`|
|Гибкость|Меньше — блокируется весь метод|Больше — можно ограничить синхронизацию только нужным кодом|
|Производительность|Может быть хуже при большом методе|Может быть лучше, если синхронизация минимальна|

---

#### 🔹 **Пример**

java

КопироватьРедактировать

`public class Counter {     private int count = 0;     private final Object lock = new Object();      // Синхронизированный метод     public synchronized void increment() {         count++;     }      // Синхронизированный блок с пользовательским монитором     public void incrementWithLock() {         synchronized (lock) {             count++;         }     } }`

В первом случае монитором будет `this`, во втором — объект `lock`.

---

#### 🔹 **Итог**

- `synchronized` контролирует доступ к разделяемым ресурсам, предотвращая гонки.
    
- Может применяться к методам и блокам кода.
    
- Монитором может быть любой объект.
    
- Синхронизированный блок более гибкий и предпочтителен, когда нужна частичная синхронизация.
    
- Важно избегать чрезмерной синхронизации для повышения производительности и предотвращения дедлоков.

### 1️8️. **Что такое атомарные классы**
#### 🔹 **Как работают атомарные классы (например, `AtomicLong`)?**

✅ **Атомарные классы** — это классы из пакета `java.util.concurrent.atomic`, которые предоставляют **потокобезопасные операции над переменными без использования блокировок** (`synchronized`).

Пример таких классов:
- `AtomicInteger`
- `AtomicLong`
- `AtomicBoolean`
- `AtomicReference` и др.

⚙ **Как это работает?**

- Атомарные классы используют низкоуровневые примитивы процессора (например, инструкции `compare-and-swap` — CAS).
    
- CAS позволяет сравнить значение переменной с ожидаемым и, если они равны, обновить значение **за одну атомарную операцию**.
    
- CAS реализуется внутри JVM через неблокирующие механизмы, что делает операции над атомарными классами **быстрыми и не блокирующими потоки**.
    

Пример использования:

`import java.util.concurrent.atomic.AtomicLong;  public class Counter {     private final AtomicLong count = new AtomicLong(0);      public void increment() {         count.incrementAndGet(); // атомарное увеличение на 1     }      public long get() {         return count.get(); // безопасное чтение     } }`

🔑 Методы `AtomicLong`:

- `incrementAndGet()` — увеличивает значение на 1 и возвращает его.
- `getAndIncrement()` — возвращает текущее значение и затем увеличивает на 1.
- `compareAndSet(expected, update)` — если текущее значение равно `expected`, устанавливает `update` и возвращает `true`.

---

#### 🔹 **В каких сценариях атомарные классы предпочтительнее `synchronized`?**

💡 **Когда стоит выбирать атомарные классы вместо `synchronized`:**

1️⃣ Когда требуется **быстрая работа с простыми данными**, например счётчиками, флагами или ссылками, где нужна только атомарность изменения, без сложной логики в критической секции.

2️⃣ Когда критическая секция содержит **только одну операцию над переменной**:
- увеличение/уменьшение числа
- смена ссылки
- установка значения при условии (CAS)

3️⃣ Когда важна **высокая производительность в многопоточной среде**, так как атомарные классы работают быстрее `synchronized`, особенно при большом числе потоков, за счёт отсутствия блокировок.

---

#### 🔹 **Когда атомарные классы не подходят?**

❌ Если критическая секция содержит **несколько связанных действий**, требующих согласованности, атомарные классы не помогут — там лучше использовать `synchronized` или `Lock`.  
Например:

java

КопироватьРедактировать

`// НЕ получится реализовать атомарно с AtomicLong: if (count.get() < limit) {     count.incrementAndGet(); }`

Между чтением и увеличением состояние может измениться другим потоком. Тут потребуется блокировка.

---

#### 🔹 **Итог**

|Атомарные классы|synchronized|
|---|---|
|Лёгкие, неблокирующие|Блокирующие|
|Отлично подходят для простых атомарных операций|Подходят для сложных, связанных операций|
|Выше производительность в многопоточной среде|Производительность ниже из-за блокировок|
|Используют CAS (compare-and-swap)|Используют мониторы и блокировки|

### 1️9️. **Что такое Happens-before в Java Memory Model (JMM)**
#### 🔹 **Как happens-before гарантирует видимость изменений между потоками?**

✅ **Happens-before** — это ключевое понятие в _Java Memory Model (JMM)_, которое описывает правила упорядочивания операций в многопоточной среде.

⚙ **Что означает happens-before?**

- Если операция A _happens-before_ операции B, это гарантирует два свойства:  
    1️⃣ **Порядок исполнения:** A произойдёт до B.  
    2️⃣ **Видимость:** все изменения в памяти, сделанные A, будут видны B.
    

💡 Без отношения happens-before между двумя потоками:

- Поток может видеть устаревшие значения переменных.
- Потоки могут выполнять операции в порядке, отличном от написанного в коде (из-за оптимизаций компилятора/JVM/процессора).

📌 **Пример проблемы без happens-before**

java

КопироватьРедактировать

`// Поток 1 flag = true;  // Поток 2 if (flag) {     // может не увидеть изменения flag }`

Если нет happens-before между записью `flag = true;` и чтением `flag`, второй поток может не увидеть `true`.

---

#### 🔹 **Примеры действий, которые создают happens-before отношения**

Вот основные конструкции Java, которые создают гарантии happens-before:

---

✅ **1️⃣ В пределах одного потока**

- Все действия в одном потоке происходят в том порядке, в котором они написаны в коде (по программе):

java

КопироватьРедактировать

`x = 1;   // happens-before y = x + 1;`

---

✅ **2️⃣ `synchronized` блоки**

- Освобождение монитора (выход из `synchronized`) в одном потоке happens-before захвата этого же монитора другим потоком.
    

java

КопироватьРедактировать

`synchronized(lock) {     sharedVar = 42;  // изменения видны }  // другой поток synchronized(lock) {     // увидит sharedVar = 42 }`

---

✅ **3️⃣ Volatile**

- Запись в `volatile` переменную happens-before чтения этой переменной другим потоком:

`flag = true;  // volatile запись // в другом потоке if (flag) {   // volatile чтение     // гарантированно видит flag = true }`

---

✅ **4️⃣ Запуск потоков**
- Вызов `Thread.start()` happens-before началом выполнения потока.
- Завершение потока (нормальное или через `Thread.join()`) happens-before возвращением из `join()`.

`Thread t = new Thread(() -> { /* ... */ }); t.start();  // старт happens-before run()  t.join();   // завершение потока happens-before продолжение в join()`

---

✅ **5️⃣ Конструкторы**

- Завершение конструктора объекта happens-before предоставлением ссылки на этот объект другим потокам (⚠️ кроме случаев утечки ссылки из конструктора).

---

✅ **6️⃣ `Executor` и `Future`**
- Завершение задачи в `Future` happens-before возврата из `get()` этого `Future`.

---
#### 🌟 Итог

| Конструкция                          | Создаёт happens-before? |
| ------------------------------------ | ----------------------- |
| `synchronized` (release-acquire)     | ✅                       |
| `volatile` (write-read)              | ✅                       |
| `Thread.start()`                     | ✅                       |
| `Thread.join()`                      | ✅                       |
| Внутрипоточные операции              | ✅                       |
| `Executor.submit()` → `Future.get()` | ✅                       |

### 2️0️. **Как создавать потоки в Java**
#### 🔹 **Способы создания потоков**

В Java потоки можно создавать несколькими способами:

✅ **1️⃣ Наследование от `Thread`**

`class MyThread extends Thread {     @Override     public void run() {         System.out.println("Hello from thread!");     } }  MyThread t = new MyThread(); t.start();  // запускаем поток (не run(), иначе не будет нового потока!)`

📌 Минус: класс уже занят наследованием от `Thread`, нельзя наследовать от другого класса.

---

✅ **2️⃣ Реализация интерфейса `Runnable`**

`class MyRunnable implements Runnable {     @Override     public void run() {         System.out.println("Hello from runnable!");     } }  Thread t = new Thread(new MyRunnable()); t.start();`

📌 Гибче: можно реализовать другие интерфейсы.

---

✅ **3️⃣ Лямбда или анонимный класс**

java

КопироватьРедактировать

`Thread t = new Thread(() -> System.out.println("Hello from lambda!")); t.start();`

📌 Краткий и читаемый код.

---

✅ **4️⃣ Использование пула потоков (через `ExecutorService`)**

java

КопироватьРедактировать

`ExecutorService executor = Executors.newFixedThreadPool(2); executor.submit(() -> System.out.println("Hello from pool!")); executor.shutdown();`

📌 Рекомендуется для управления большим количеством потоков.

---

### 🔹 **Что такое `synchronized` и как он работает?**

`synchronized` — это ключевое слово, которое гарантирует:

- Взаимное исключение (mutual exclusion): только один поток может выполнять синхронизированный блок/метод на одном объекте в данный момент.
    
- Happens-before: выход из `synchronized` блока в одном потоке happens-before входа в этот блок другим потоком на том же мониторе.
    

👉 Пример использования:

java

КопироватьРедактировать

`public synchronized void safeMethod() {     // синхронизированный метод (монитор — this) }  public void safeBlock() {     synchronized (lock) {         // критическая секция     } }`

📌 Каждый объект в Java имеет _монитор_ (lock), который используется в `synchronized`.

⚠ **Важно:**

- Если поток захватил монитор объекта, другие потоки блокируются на входе в этот блок/метод.
    
- Монитор освобождается при нормальном выходе или при выбросе исключения.
    

---

### 🔹 **Какие есть способы синхронизации потоков?**

✅ **1️⃣ `synchronized`**

- Блоки и методы, которые ограничивают доступ к критическим секциям.
    

---

✅ **2️⃣ `volatile`**

- Обеспечивает happens-before между записью и чтением.
    
- Не блокирует потоки, но не гарантирует атомарность операций.
    

---

✅ **3️⃣ `Lock` (из пакета `java.util.concurrent.locks`)**

java

КопироватьРедактировать

`Lock lock = new ReentrantLock(); lock.lock(); try {     // критическая секция } finally {     lock.unlock(); }`

📌 Более гибкий, чем `synchronized`:

- возможность прерывания
    
- попытка захвата lock с таймаутом
    
- возможность fair lock (по очереди)
    

---

✅ **4️⃣ Высокоуровневые конструкции из `java.util.concurrent`**

- `CountDownLatch`, `CyclicBarrier`, `Semaphore`, `Exchanger`, `Phaser` — позволяют координировать работу потоков.

---

✅ **5️⃣ Атомарные классы**

- `AtomicInteger`, `AtomicLong`, `AtomicReference` и др. — предоставляют атомарные операции без явной блокировки.

---

✅ **6️⃣ `Thread.join()`**

- Синхронизация по завершению потока: один поток ждёт другой.

---

💡 **Итог**

|Способ|Для чего подходит|
|---|---|
|`synchronized`|Критические секции, простая блокировка|
|`Lock`|Гибкая блокировка с прерыванием/таймаутами|
|`volatile`|Гарантия видимости (не атомарность)|
|Атомарные классы|Безблокирующие атомарные операции|
|`ExecutorService`|Управление потоками|
|`CountDownLatch`, `Semaphore`|Согласование потоков|

### 21. **Чем отличается Heap от Stack?**

| Параметр                  | Heap                                                         | Stack                                                             |
| ------------------------- | ------------------------------------------------------------ | ----------------------------------------------------------------- |
| 📌 **Назначение**         | Хранение объектов и их данных (динамическая память)          | Хранение локальных переменных, параметров методов, фреймов вызова |
| 📌 **Жизненный цикл**     | Объекты живут, пока на них есть ссылки, или до сборки мусора | Данные уничтожаются при выходе метода из стека вызова             |
| 📌 **Управление памятью** | Управляется JVM через Garbage Collector (GC)                 | Управляется строго по принципу LIFO (last-in-first-out)           |
| 📌 **Доступ**             | Более медленный доступ (нет строгой структуры)               | Быстрый доступ (упорядочено)                                      |
| 📌 **Область памяти**     | Общая для всех потоков                                       | Обычно создаётся отдельный стек для каждого потока                |

---

### 🔹 **Какие объекты хранятся в Heap, а какие в Stack?**

✅ **Heap**

- Все экземпляры классов (объекты).
- Массивы.
- Вложенные объекты, referenced другими объектами.

📌 Например:

`Person p = new Person();  // сам объект Person хранится в Heap`

✅ **Stack**

- Примитивные типы данных (int, long и т.д.), объявленные в методе.
- Ссылки на объекты (не сами объекты, а ссылки на них в Heap).
- Адрес возврата из метода, параметры метода.

📌 Например:

`void foo() {     int x = 10;      // x в Stack     Person p = new Person();  // p (ссылка) в Stack, сам Person в Heap }`

---

### 🔹 **Как Garbage Collector работает с Heap?**

Garbage Collector (GC) отвечает за автоматическую очистку памяти в Heap от объектов, на которые нет активных ссылок (т.е. мусор).

💡 **Основная идея:**  
GC отслеживает ссылки между объектами и собирает те, которые недостижимы из корневых точек (GC roots):

- локальные переменные стека
- статические поля классов
- ссылки из JNI (native code)

---

✅ **Этапы работы GC (обобщённо):**  
1️⃣ **Маркировка (Marking)**  
GC обходит граф объектов, начиная от GC roots, и помечает все доступные объекты.

2️⃣ **Очистка (Sweeping / Deletion)**  
Удаляет все объекты, которые не были помечены (т.е. недостижимые).

3️⃣ **Компактизация (Compacting)**  
Перемещает оставшиеся объекты, чтобы устранить фрагментацию памяти.

---

✅ **Как устроен Heap для GC**  
Heap делится на области:

- **Young Generation**
    - Eden: новые объекты
    - Survivor: объекты, пережившие несколько сборок
        
- **Old Generation**
    - долгоживущие объекты
        
- (иногда) **Metaspace** / PermGen (для данных классов, метаданных — это уже не Heap)

📝 Новые объекты чаще всего быстро становятся мусором → сборки Young Generation происходят чаще (Minor GC).

Объекты, которые "дожили" до определённого числа сборок, перемещаются в Old Generation → сборка Old Generation реже (Major GC / Full GC).

---

### ⚠ **Пример жизненного цикла объекта в Heap**

java

КопироватьРедактировать

`public void method() {     Person p = new Person();  // p — ссылка в Stack, объект Person — в Heap     // пока метод работает, p является GC root }`

👉 Когда метод завершился, p исчезает из стека. Если других ссылок на Person нет — объект становится кандидатом на сборку.

### 22. **Как работает `ConcurrentHashMap`?**

`ConcurrentHashMap` — это потокобезопасная реализация хэш-таблицы в Java, предназначенная для работы в многопоточной среде без использования глобальной блокировки всей таблицы.  
Его ключевая цель — обеспечить возможность конкурентного доступа с минимальными блокировками и высокой производительностью.

⚙️ **Механизм работы:**

- **До Java 8:** карта была разделена на сегменты (Segment) — каждый сегмент был блокировкой (lock), и операции над разными сегментами могли выполняться параллельно.
    
- **Начиная с Java 8:** сегменты были убраны, используется оптимизированная структура:
    
    - **Bucket'ы (корзины)** могут быть связаны в виде списков или деревьев (как в `HashMap`).
        
    - Для модифицирующих операций используются:
        
        - Локальные блокировки отдельных корзин (узлов или дерева), а не всей карты.
        - CAS (Compare-And-Swap) операции для атомарных действий без блокировок.
            
    - Чтения большинства данных происходят **без блокировок**, только с volatile полями для обеспечения видимости.

---

### 🔹 **Какие операции в `ConcurrentHashMap` являются атомарными?**

✅ **Атомарные операции:**

- `get(key)`  
    → потокобезопасное и неблокирующее чтение.
    
- `put(key, value)`  
    → атомарно вставляет или обновляет значение для ключа.
    
- `remove(key)`  
    → атомарно удаляет ключ и связанное с ним значение.
    
- `putIfAbsent(key, value)`  
    → вставляет значение, если ключ отсутствует (атомарно).
    
- `compute`, `computeIfAbsent`, `computeIfPresent`  
    → атомарные модификации значений на основе вычислений.
    
- `replace(key, oldValue, newValue)`  
    → атомарно заменяет значение, если текущее равно `oldValue`.
    

---

⚠ **Неатомарные составные операции:**  
Операции вроде:

java

КопироватьРедактировать

`if (!map.containsKey(k)) {     map.put(k, v); }`

не являются атомарными, потому что между `containsKey` и `put` карта может измениться другим потоком. Для таких сценариев используйте встроенные методы типа `putIfAbsent`.

---

### 🔹 **Какие еще есть потокобезопасные коллекции?**

💡 **Стандартные потокобезопасные коллекции в Java:**

| Коллекция                                                                | Назначение                                                                                |
| ------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------- |
| `ConcurrentSkipListMap`, `ConcurrentSkipListSet`                         | Потокобезопасные, сортированные, на основе skip list                                      |
| `ConcurrentLinkedQueue`                                                  | Неконкурентные вставка/удаление в очередь                                                 |
| `ConcurrentLinkedDeque`                                                  | Двусторонняя неблокирующая очередь                                                        |
| `CopyOnWriteArrayList`, `CopyOnWriteArraySet`                            | Коллекции для сценариев с частыми чтениями и редкими записями (модификации создают копию) |
| `BlockingQueue` (и подтипы: `LinkedBlockingQueue`, `ArrayBlockingQueue`) | Очереди с поддержкой блокирующих операций (ожидание при вставке/извлечении)               |
| `SynchronousQueue`                                                       | Очередь без буфера (рукопожатие между потоками)                                           |
| `LinkedTransferQueue`                                                    | Более гибкая неблокирующая очередь с возможностью передачи данных между потоками          |

---

### 💡 **Пример использования `ConcurrentHashMap`:**

java

КопироватьРедактировать

`ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>(); map.putIfAbsent("key", 1); map.computeIfPresent("key", (k, v) -> v + 1); int value = map.get("key"); // безопасное чтение`

---

### ⚠ Важный вывод:

`ConcurrentHashMap` идеально подходит для сценариев, где:

- требуется высокая конкуренция при чтении;
    
- часто происходят независимые модификации разных ключей;
    
- необходимы атомарные составные операции (например, `compute`, `merge`).

### 23. **Как работает `CopyOnWriteArrayList`?**

`CopyOnWriteArrayList` — это потокобезопасная реализация `List`, которая используется в многопоточной среде, когда:

- число операций **чтения** существенно больше числа операций **записи**;
- важна простота реализации потокобезопасности без сложной синхронизации.

⚙ **Принцип работы:**

- Всякий раз при изменении списка (например, при `add`, `set`, `remove`) создается **новая копия внутреннего массива**.
- Чтения происходят напрямую из текущего массива **без блокировок**.
- Модификации используют `ReentrantLock` (на время создания новой копии), чтобы гарантировать атомарность изменения.

💡 **Пример кода:**

java

КопироватьРедактировать

`CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>(); list.add("one"); list.add("two");  for (String s : list) {   // безопасно, даже если другой поток изменяет list     System.out.println(s); }`

---

### 🚀 **Когда это полезно**

- Когда множество потоков **читают данные** из списка, а записи происходят редко (например, конфигурация, подписчики событий, кэш данных).
- Когда нужно безопасно итерироваться по коллекции, не опасаясь `ConcurrentModificationException`.

---

### ⚠ **Минусы**

- Высокие накладные расходы на память и время при частых изменениях (каждая модификация создает новый массив).
- Неэффективен при большом количестве записей.

---

### 🔹 **Какие еще есть потокобезопасные коллекции?**

✅ **Другие стандартные потокобезопасные коллекции в Java:**

|Коллекция|Особенности|
|---|---|
|`ConcurrentHashMap`|Потокобезопасная хэш-таблица с поддержкой конкурентного доступа|
|`ConcurrentLinkedQueue`|Неблокирующая очередь на основе связанного списка|
|`ConcurrentLinkedDeque`|Неблокирующая двусторонняя очередь|
|`BlockingQueue` (например, `LinkedBlockingQueue`, `ArrayBlockingQueue`)|Очереди с блокирующими операциями вставки и извлечения|
|`ConcurrentSkipListMap`, `ConcurrentSkipListSet`|Потокобезопасные отсортированные коллекции|
|`CopyOnWriteArraySet`|Реализация Set на основе `CopyOnWriteArrayList`|
|`SynchronousQueue`|Очередь без буфера (каждая вставка ожидает соответствующего извлечения)|
|`LinkedTransferQueue`|Неблокирующая очередь с возможностью передачи элемента без хранения|

---

### 💡 **Ключевая идея**

`CopyOnWriteArrayList` = отличный выбор, если:

- большинство операций — это чтение;
    
- итерация должна быть безопасной без блокировок;
    
- не критична стоимость модификаций.

### 24. **Что такое `ExecutorService`?**

`ExecutorService` — это интерфейс в пакете `java.util.concurrent`, который управляет пулом потоков и позволяет:

- передавать задачи на выполнение;
- управлять жизненным циклом потоков (например, завершать работу пула);
- планировать выполнение задач (с отложенным запуском или по расписанию).

✅ **Преимущества использования `ExecutorService`:**

- управление потоками (нет необходимости создавать и управлять потоками вручную);
- эффективное переиспользование потоков;
- упрощение обработки многопоточности и ошибок.

---

### 🔹 **Основные фабричные методы `Executors` и их реализации**

Java предоставляет фабричные методы в классе `Executors` для создания различных пулов потоков:

---

#### 1️⃣ **`Executors.newFixedThreadPool(int nThreads)`**

- Создаёт пул с фиксированным числом потоков (ровно `nThreads` потоков).
- Если все потоки заняты, новые задачи ставятся в очередь.
- Подходит для задач с известным числом одновременно работающих потоков.

💡 _Пример:_

`ExecutorService executor = Executors.newFixedThreadPool(4);`

Используется, если нужно ограничить параллелизм (например, обработка запросов к БД).

---

#### 2️⃣ **`Executors.newCachedThreadPool()`**

- Создаёт пул без фиксированного размера:
    - создаются новые потоки по мере необходимости;
    - простаивающие (idle) потоки удаляются через 60 секунд.
        
- Хорошо подходит для большого числа короткоживущих асинхронных задач.

💡 _Пример:_

`ExecutorService executor = Executors.newCachedThreadPool();`

⚠ Использовать осторожно: нет ограничения на число потоков → возможна перегрузка системы.

---

#### 3️⃣ **`Executors.newScheduledThreadPool(int corePoolSize)`**

- Создаёт пул, который может:
    - запускать задачи с задержкой;
    - выполнять задачи периодически.
        
- Количество потоков задаётся параметром `corePoolSize`.

💡 _Пример:_

`ScheduledExecutorService executor = Executors.newScheduledThreadPool(2); executor.schedule(() -> System.out.println("Delayed task"), 5, TimeUnit.SECONDS);`

Подходит для задач типа "таймеров", "планировщиков", мониторинга.

---

### 🔹 **Как выбрать подходящий пул потоков для задачи?**

|Сценарий|Рекомендуемый пул|
|---|---|
|Количество потоков должно быть ограничено|`FixedThreadPool`|
|Много коротких асинхронных задач, непредсказуемое количество|`CachedThreadPool` (⚠ с осторожностью)|
|Нужна отложенная или периодическая задача|`ScheduledThreadPool`|
|Ограниченное использование ресурсов сервера|`FixedThreadPool` с размером, равным числу доступных ядер CPU|
|Реализация очередей заданий с ограничением ресурсов|`FixedThreadPool` + очередь|

💡 **Принцип выбора:**

- Если нужно контролировать нагрузку → фиксированный пул.
- Если задачи редкие и быстрые → кешированный пул.
- Если нужны отложенные или повторяющиеся задачи → планировщик (`ScheduledThreadPool`).

---

### 🔹 **Пример использования с завершением пула**

`executor.shutdown();  // мягкое завершение (ждёт завершения текущих задач) executor.awaitTermination(1, TimeUnit.MINUTES);  // ждать завершения`

## 25. **Что такое `Future`?**

`Future` — это интерфейс из `java.util.concurrent`, который представляет результат асинхронной операции. Когда вы передаёте задачу в `ExecutorService`, она возвращает `Future`, чтобы:

- получить результат задачи в будущем;
- отменить задачу;
- проверить, завершена ли задача.

### ✅ Основные методы `Future`:

`V get()              // Блокирует поток до завершения задачи и возвращает результат. V get(long timeout, TimeUnit unit)                        // Ждёт ограниченное время, затем бросает TimeoutException. boolean cancel(boolean mayInterruptIfRunning)                       // Пытается отменить выполнение задачи. boolean isDone()     // Проверяет, завершена ли задача. boolean isCancelled()// Проверяет, была ли задача отменена.`

### ⚠ Ограничения `Future`:

- **Блокирующий вызов `get()`** — чтобы получить результат, поток вынужден ждать (нет возможности неблокирующей обработки результата).
- **Нет поддержки цепочек** — нельзя задавать действия, которые должны выполняться после завершения задачи.
- **Нет удобных инструментов для обработки ошибок** — приходится обрабатывать вручную.

💡 _Пример с Future_:

`ExecutorService executor = Executors.newSingleThreadExecutor(); Future<Integer> future = executor.submit(() -> 42);  // блокирующий вызов Integer result = future.get(); System.out.println(result); executor.shutdown();`

---

## 🔹 **Что такое `CompletableFuture`?**

`CompletableFuture` (появился в Java 8) — это улучшенный вариант `Future`, который:
- позволяет строить **цепочки вычислений**;
- поддерживает **неблокирующую обработку** результата;
- даёт возможность комбинировать несколько асинхронных задач;
- позволяет явно завершать или завершать с ошибкой.

### ✅ Основные возможности `CompletableFuture`:

- **`thenApply(Function)`** — применить функцию к результату.
- **`thenAccept(Consumer)`** — обработать результат без возвращения значения.
- **`thenRun(Runnable)`** — выполнить действие после завершения.
- **`thenCompose(Function)`** — запускать последующие асинхронные задачи, зависящие от результата.
- **`thenCombine` / `allOf` / `anyOf`** — комбинировать несколько `CompletableFuture`.
- **`exceptionally` / `handle`** — обработка ошибок.

💡 _Пример с CompletableFuture_:

`CompletableFuture.supplyAsync(() -> 42)     .thenApply(result -> result * 2)     .thenAccept(finalResult -> System.out.println("Результат: " + finalResult));`

✔ Здесь поток не блокируется — обработка идёт асинхронно.

---

## 🔹 **Как `CompletableFuture` решает проблемы `Future`?**

| Проблема `Future`                                  | Решение в `CompletableFuture`                                  |
| -------------------------------------------------- | -------------------------------------------------------------- |
| Блокирующий вызов `get()` для получения результата | Неблокирующие методы `thenApply`, `thenAccept`, `whenComplete` |
| Нет поддержки цепочек действий                     | Цепочки через `thenApply`, `thenCompose`, `thenCombine`        |
| Нет удобной обработки ошибок                       | Методы `exceptionally`, `handle`                               |
| Нельзя комбинировать несколько Future              | Методы `allOf`, `anyOf` для композиции                         |

---

## 🔹 Краткое сравнение

|Характеристика|`Future`|`CompletableFuture`|
|---|---|---|
|Блокирующий `get`|Да|Можно не блокировать|
|Цепочки обработки|Нет|Да|
|Обработка ошибок|Нет|Да (`exceptionally`, `handle`)|
|Комбинирование задач|Нет|Да (`thenCombine`, `allOf`)|
|Установка значения вручную|Нет|Да (`complete`, `completeExceptionally`)|

---

## 🚀 Заключение

✅ **Когда использовать `Future`?**

- Простая задача: отправить задачу и дождаться её результата в будущем без сложной обработки.

✅ **Когда использовать `CompletableFuture`?**

- Когда нужна цепочка действий.
- Когда важна неблокирующая обработка.
- Когда нужно комбинировать несколько асинхронных задач.
- Когда важна удобная обработка ошибок.

