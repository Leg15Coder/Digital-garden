==Опр.== **Персистентная СД (ПСД)** - СД, хранящая информацию об истории всех своих изменений.

==Опр.== **Версия СД** - состояние СД на определённый момент времени.

# Персистентный массив

У массива принципиально два основных метода:
- записать значение в ячейку
- узнать значение в ячейке (теперь с учётом версии)

Для достижения свойства персистентности, поставим каждой ячейке массива в соответствие свой массив пар вида $(ver,\ val)$, в которой каждая запись соответствует изменению значения в этой ячейки. То есть, если на версиях $v$ и $v + 2$ значения в данной ячейки были равны $x$ и $z$ соответственно, то в соответствующем массиве будут подряд идущие пары $(v,\ x)$ и $(v + 2,\ z)$. 

Поиск значения в ячейке в конкретной версии будет осуществляться через бинпоиск по соответствующему ей массиву. Заметим, что при такой реализации не меняется асимптотика основных операций массива, поэтому рассмотрим только асимптотику восстановления версий.

### Асимптотика

Пусть $q$ - количество версий массива, а $n$ - максимальный размер массива, тогда:
Асимптотика по памяти: $O(q + n)$
Асимптотика по времени:
- Восстановление значения ячейки: $O(\log q)$
- Восстановление версии массива: $O(n \log q)$

# Персистентный стек

1) Каждый элемент мы будем хранить в узле, который имеет ровно одного родителя. Родитель данного элемента это тот элемент, который лежит до него в стеке.
2) Пустой стек считается 0-й версией СД и состоит из фиктивного узла (назовём его "дно"). По определению данный курс получился корнем дерева узлов.
3) Будем хранить указатель на верхний элемент в текущей версии стека (назовём его head)
4) Версии стека будем хранить в массиве, причём нам достаточно хранить указатель на head данной версии.
5) При добавлении элемента мы его родителем ставим текущий head, после чего за head обозначим новый элемент. При удалении, фактически мы не удаляем верхний элемент, а смещаем указатель head на его родителя.

Заметим, что при такой реализации не меняется асимптотика основных операций стека, поэтому рассмотрим только асимптотику восстановления версий.

### Асимптотика

Пусть $q$ - количество версий стека, тогда:
Асимптотика по памяти: $O(q)$
Асимптотика по времени:
- Восстановление верхнего значения в конкретной версии: $O(1)$
- Восстановление версии стека: $O(1)$

# Персистентное [[Дерево отрезков|ДО]] (ПДО)

1) Заметим, что все операции с ДО начинаются с его корня. Поэтому в качестве версии ДО будем хранить указатель на корень ДО данной версии. Корни будем хранить в массиве.
2) Операции, которые не изменяют ДО не создают новые версии.
3) Пусть появилась новая версия ДО в результате некоторой операции. Для него сразу создадим корень и добавим его в массив (изначально дети у корня те же, что и у прошлой версии). Для корня запустим рекурсивный алгоритм:
	1) Если в левом сыне (или его потомках) текущей вершины происходили изменения, то 
		1) создадим новую версию левого сына и заменим у текущий вершины левого сына на его новую версию. 
		2) Запустим рекурсивно текущий алгоритм от левого сына.
	2) Аналогично первому пункту проделаем и для правой вершины.
	3) Обновим значение в текущей вершине по её детям.

Проанализировав данный алгоритм можно понять, что он работает по тому же пути, по которому работала операция, вызвавшая появление новой версии ДО. То есть
1) Создание новой версии можно делать "параллельно" выполнению основной операции
2) Данный алгоритм не влияет на асимптотику основных операций ДО.

### Асимптотика

Рассмотрим асимптотику восстановления версий. Пусть $q$ - количество версий ДО, а $n$ - максимальный его размер, тогда:
Асимптотика по памяти: $O(q \log n + n)$
Асимптотика по времени:
- Выполнение стандартной операции над произвольной версией ДО: $O(\log n)$
- Восстановление версии ДО: $O(n)$
