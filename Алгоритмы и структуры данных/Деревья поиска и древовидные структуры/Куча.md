==Опр.== **Куча** - неупорядоченная структура данных, способная добавлять новые элементы и находить или удалять элементы, отвечающие определённым свойствам.

- ***Свойство кучи***: любой ребёнок узла в дереве не больше родителя.
- **Следствия из свойства кучи**: в корне лежит наименьший элемент и все потомки узла не больше него самого.

## Двоичная куча

- Данная структура данных основана на [[Понятие графа|бинарном дереве]], сохранят *свойство кучи* и способна:
	1) Добавлять элемент
	2) Находить минимальный элемент
	3) Удалять минимальный элемент

### Просеивание вверх

- Пусть для узла $v$ нарушается свойство кучи так, что он меньше своих предков. Тогда операция "просеивание вверх" должна вернуть свойство кучи.

#### Алгоритм

1) Пока $v$ меньше родителя $p$, меняем $v$ и $p$ местами. (если $v$ является корнем, то просеивание вверх не выполняется)

#### Корректность

Мы предполагаем, что свойство кучи нарушает только узел $v$. То есть все его предки меньше друг друга, а все его дети меньше его предков. Так как просеивание вверх не меняет относительный порядок детей и родителей $v$, то между ними свойство кучи не нарушается, а между $v$ и другими детьми предка $v$ свойство кучи нарушиться не может, так как предок заменяется на ещё более маленький элемент.

### Просеивание вниз

- Пусть для узла $v$ нарушается свойство кучи так, что он больше хотя бы одного своего ребёнка. Тогда операция "просеивание вниз" должна вернуть свойство кучи.

#### Алгоритм

1) Пока $v$ больше хотя бы одного ребёнка, то выбираем меньшего из детей $u$ и меняем $v$ и $u$ местами.

#### Корректность

Мы предполагаем, что свойство кучи нарушает только узел $v$. То есть все его предки меньше друг друга, а все его дети меньше его предков. Так как просеивание вверх не меняет относительный порядок $v$ и родителей $v$, то между ними свойство кучи не нарушается, а между детьми $v$ свойство кучи нарушиться не может, так как предок заменяется на ещё более маленький элемент.

### Методы кучи

1) Просеиванием узла $v$ назовём метод, который определят как $v$ нарушает свойство кучи и применят соответствующее просеивание (вверх или вниз). Если $v$ не нарушает свойство кучи, то просеивание ничего не делает.
2) Благодаря свойству кучи найти минимальный элемент легко - он всегда будет в корне.
3) Добавление нового элемента происходит следующим образом: 
	1) Добавляем новый лист на минимальный слой, который ещё не заполнен
	2) В значение этого листа записываем соответствующий элемент
	3) Просеиваем этот лист (вверх)
4) Удаление минимального элемента происходит следующим образом: 
	1) Выбираем произвольный лист с нижнего слоя дерева и меняем его с корнем местами (значениями)
	2) Удаляем этот лист
	3) Просеиваем корень (вниз)

Так как просеивание затрагивает каждый слой дерева не более одного раза, то оно занимает $O(h)$ времени, где $h$ - высота дерева. Так как удаление и добавление элементов происходит по слоям, то все слои, кроме быть может последнего, полностью заполнены. Так как на $k$-м слое максимум $2^{k-1}$ элементов, то $h = O(\log n)$.

**Итоговая асимптотика по памяти**: $O(n)$

**Итоговая асимптотика по времени**:
	1) Добавление элемента за $O(\log n)$
	2) Удаление минимального элемента за $O(\log n)$
	3) Нахождение минимального элемента за $O(1)$

### Построение кучи по массиву
#### Алгоритм

Массив - одна из реализаций кучи. Представим, что элемент под индексом 0 - это корень дерева, а для элемента с индексом $k$ детьми будут элементы под индексами $2k$ и $2k+1$, тогда от всех индексов, которые не являются листьями кучи, по убыванию индекса запускаем просеивание вниз. В итоге получим корректную кучу.

#### Корректность

Докажем индукцией по убыванию индекса просеивания:

**База**: (тривиальный случай, который алгоритм условно пропускает) любой лист сам по себе является корректной кучей из одно элемента.

**Предположение**: оба поддерева текущего узла являются корректными кучами.

**Шаг**: рассматривая дерево из текущего узла и его поддеревьев, мы получаем кучу, в которой только один узел нарушает её свойство и этот узел - корень. Операция просеивания восстанавливает свойство и всё это дерево становится корректной кучей.

#### Асимптотика

Так как мы идём снизу вверх, то высота просеивания так же увеличивается от $2$ до $\log n$, а на каждом уровне вдвое меньше узлов, чем на ранее рассмотренном, то суммарное время $T(n) = \sum\limits_{h=2}^{\log_2 n}\frac{n}{2^h} \cdot O(h) = O(n)$.

По доп. памяти асимптотика $O(1)$ так как работаем над исходным массивом и только над ним.

### Модификации кучи

1) Куча, которая поддерживает удаление произвольного элемента

- Создаём вторую кучу, в которую будем добавлять элементы, которые нужно удалить.
- Если в исходной куче и куче из удалённых элементов в какой-то момент корень совпадает, то удаляем минимум из обоих.

2) Куча на нескольких операциях (например, минимум и максимум)

- Для каждой операции храним свою версию кучи с модификацией произвольного удаления.
- Запрос на удаление максимума/минимума обрабатываем как запрос на произвольное удаление.
- Запрос на взятие максимума/минимума обрабатываем из той кучи, которая поддерживает эту операцию.
- Каждую операцию применяем одновременно ко всем версиям кучи.
