==Опр.== **Фибоначчиева куча** - двусвязный список деревьев, каждое из которых сохраняет [[Куча|свойство кучи]], и при этом каждый узел дерева хранит детей в двусвязном списке с пометкой изменялся ли фактический и количественный состав детей.

![[extract-min-1.png]]

## Операции

#### 1. Взять минимум

**Асимптотика**: $O(1)$

**Реализация**: Всегда хранить указатель на минимальный элемент и при добавлении новых элементов или удалении старых обновлять его.

#### 2. Слияние двух фибоначчиевых куч

**Асимптотика**: $O(1)$

**Реализация**: Слить два двусвязных списков деревьев и обновить минимум.

#### 3. Добавление элемента

**Асимптотика**: $O(1)$

**Реализация**: Добавить новый элемент как дерево из одной вершины в список деревьев.

#### 4. Удаление минимального элемента

**Асимптотика**: $O^*(\log n)$

**Реализация**: 
1) Слить текущую кучу с двусвязным списком детей удаляемого элемента. 
2) Пусть $D$ - максимальная степень среди корней всех деревьев (Можно поддерживать за $O(1)$).
3) Заведём массив размера $D + 1$ (назовём его $C$).
4) Для каждого дерева в списке:
	1) Обновить информацию в корне дерева (указать, что это корень, если ещё не указано).
	2) Пусть $d$ - степень корня текущей вершины.
	3) *Если* `C[d] is null`:
		Запишем в созданный ранее массив под индексом, равным степени корня текущего дерева, ссылку на текущее дерево.
	4) *Иначе*:
		1) Рассматриваем два дерева: текущее и то, которое указано в $C[d]$. 
		2) То, у которого значение корня больше, подвешиваем к корню второго. 
		3) При этом в двусвязном списке деревьев вырезаем переподвешенное дерево, "склеивая" его соседей. (так как знаем ссылку на это дерево, то можем сделать это за $O(1)$). 
		4) Удаляем значение $C[d]$. 
		5) Теперь степень вершины равна $d + 1$ и мы рассматриваем значение в $C[d+1]$, повторяя пункты 4.3 и 4.4.$*$, пока не выйдем из рекурсии.

#### 5. Изменение элемента (уменьшение)

**Асимптотика**: $O(1^*)$

**Реализация**: Если изменился корень - обновляем указатель на минимум. Иначе, вырезаем изменённый элемент с его поддеревом и добавляем в двусвязный список как новое дерево. У бывшего родителя вырезанного элемента помечаем, что состав его детей поменялся. При этом, если этот родитель не корень и уже имеет пометку об изменении детей, то вырезаем и его вместе с поддеревом и добавляем как новое дерево, помечая уже его родителя.

#### Доказательство асимптотики

Воспользуемся *методом монеток* для обоснования асимптотики:
1) На каждый элемент выдаём 3 монеты.
2) Взятие минимума стоит 0 монет.
3) Добавление стоит 0 монет.
4) Слияние куч стоит 0 монет.
5) Вырезать элемент и сделать его корнем стоит 1 монету. (следовательно уменьшение элемента тратит $O(1^*)$ времени)
6) Переподвесить дерево стоит 1 монету.

Тогда удаление минимального элемента стоит $O^*(D(n))$, где $D(n)$ - максимальная степень корня в куче из $n$ элементов.

Пусть $S(k)$ - минимальное количество вершин в дереве фибоначчиевой кучи, степень корня которого равна $k$, тогда 
1) $S(0) = 1$, $S(1) = 2$.
2) Пусть $v$ - корень дерева, а $u_i$ - его дети, тогда $S(\deg v) \geq \sum\limits_{i=1}^k S(\deg u_i)$. При этом $\deg u_i \geq i ]- 1$, поскольку мы могли вырезать у ребёнка не более одного ребёнка (иначе бы вырезали $u_i$ тоже). То есть для $k > 1$ верно $S(k) \geq 2 + \sum\limits_{i=0}^{k-2} S(i) = F_{k+2}$, где $F_n$ - $n$-е число фибоначчи. А так как по формуле Бине $F_n = \frac{\varphi^n - (-\varphi)^{-n}}{\sqrt{5}}$, где $\varphi$ - золотое сечение, то $S(k) = \Omega(\varphi^{k+2})$.
3) Если в дереве $m$ вершин, то $\deg v \leq \log_{\varphi} m$ $\Rightarrow$ $D(n) = \max\limits_{\deg v} \deg v = O(\log n)$.
4) *Замечание*: сложность удаления равна $O^*(\log n)$ поскольку нижняя оценка на $\deg u_i$ основана на амортизированной операции.
