- ***Данная сортировка [[Понятие сортировки#Сортировка на сравнениях|основана на сравнениях]].***
## Алгоритм

1) Если длина массива один, то он отсортирован (тривиальный случай)
2) Иначе разбиваем массив на две равные части
3) Каждую часть рекурсивно сортируем слиянием
4) Применяем операцию слияния двух частей: 
	1) Ставим указатели $l$ и $r$ на первые элементы обоих частей
	2) Пока оба указателя не вышли за свои части:
		1) Если $r$ вышел за границы или элемент под $l$ меньше элемента под $r$, то в $(l + r)$-ю ячейку исходного массива записываем элемент, который под $l$
		2) Иначе в $(l + r)$-ю ячейку исходного массива записываем элемент, который под $r$

## Корректность

1) Тривиальный случай корректен.
2) Предположим (по индукции) что предыдущий шаг сортировки корректен (обе части отсортированы).
3) В силу предположения $\forall k\ :$ $a_l \leq a_{l+k}$ и $a_r \leq a_{r+k}$. В ходу слияния мы выбрали наименьший элемент (боо под $l$). То есть $a_l \leq a_r \leq a_{r+k}$ - то есть мы выбрали самый маленький элемент из всех оставшихся и поставили в начало. Данная операция корректна и сохраняет свойство отсортированности (так как рассматриваются только начальные элементы частей), следовательно слияние корректно.
4) Корректность доказана по индукции.

## Асимптотика

Применим [[Асимптотический анализ алгоритма#Мастер-Теорема|Мастер-Теорему]]: $a = 2$, $b = 2$, $c = 1$ (каждый элемент в слиянии участвует ровно один раз) $\Longrightarrow$ асимптотика по времени равна $\Theta(n \log n)$.

По памяти можно достичь асимптотику $O(n)$ если хранить только текущий уровень рекурсии в дополнительной памяти.
