- *Второе название - сортировка Хоара.*
- Вероятностная сортировка, [[Понятие сортировки#Сортировка на сравнениях|основанная на сравнениях]].

## Алгоритм

Алгоритм рекурсивный, на каждом шаге рекурсии:
1) Тривиальный случай - массив из одного элемента или нуля элементов уже отсортирован
2) Выбираем некоторый элемент из массива (назовём его $pivot$)
3) Одним проходом делим массив на три части: элементы меньше, равные и больше $pivot$
4) Для первой и третьей части рекурсивно запускаем быструю сортировку

## Корректность

Тривиальный случай корректен. 
Предположим, что предыдущий шаг корректен. Тогда первая и третья части отсортированы. Вторая часть тоже отсортирована, так как содержит только одинаковые элементы, при этом максимальный элемент первой части $< pivot$, а минимальный элемент третьей части $> pivot$, то есть все три части тоже расположены по возрастанию, следовательно массив отсортирован.

## Асимптотика

Асимптотика по времени зависит от выбора $pivot$. Если выбирать его случайно, то в среднем (мат. ожидание) алгоритм будет работать за $O(n \log n)$ (б/д), но в худшем случае может вырождаться до $O(n^2)$. Примерно такой же результат будет если каждый раз выбирать элемент с фиксированным индексом (например, средний).

## Модификации (вариации)
### Разбиение Хоара (классическое)

- В качестве $pivot$ выберем средний (по индексу) элемент массива. Деление массива будем выполнять двумя указателями:
- Заведём два указателя на начало и конец массива (назовём массив $a$) - $l$ и $r$ соотв. Пока они не встретились:
	1) Пока $a_l \leq pivot$, двигаем $l$ вправо
	2) Пока $a_r > pivot$, двигаем $r$ влево
	3) Меняем $a_l$ и $a_r$ местами и сдвигаем $l$ и $r$ навстречу друг другу
- Данное разбиение хорошо работает на практике.

### Разбиение Ломуто

- В качестве $pivot$ выбираем последний (или первый) элемент массива. Деление массива будем выполнять двумя указателями:
- Заведём два указателя, изначально оба указывают на начало массива (назовём массив $a$) - $l$ и $r$. Пока $r < |a|$:
	1) Если $a_r < pivot$, то меняем $a_l$ и $a_r$ местами, сдвигаем $l$ вправо.
	2) Сдвигаем $r$ вправо.

### Толстое разбиение

- Данное разбиение является классической модификацией быстрой сортировки. Оно подразумевает, что мы делим массив на три части: элементы меньше, равные и больше $pivot$. *(В обычной быстрой сортировке допускается делить массив на две части, а элементы равные $pivot$ оставлять в одной из частей)*
- Данное разбиение значительно ускоряет сортировку, если в массиве большое количество повторяющихся элементов.

### Рандомизированный $pivot$

- Будем выбирать $pivot$ как случайный элемент данного массива.
- Так как быстрая сортировка делает не более $n$ разбиений массива на части для рекурсивного вызова, а каждый такой вызов совершает некоторое количество итераций цикла, в каждой из которых происходит сравнение элементов с $pivot$, то время работы быстрой сортировки равно $O(n + C)$, где $C$ - суммарное число выполненных алгоритмом сравнений.

Докажем, что $$\mathbb{E}C = O(n \log n)$$
#### Доказательство.

Пусть $\{a_i\}_{i=1}^n$ - элементы массива $a$ в **уже отсортированном порядке** (то есть $\forall i \in \overline{2,n}\ :\ a_{i-1} \leq a_i$). 

Заметим, что в стандартных разбиениях $a_i$​ и $a_j$ сравниваются тогда и только тогда, когда выбранным $pivot$ оказывается один из них​. Это происходит потому что:
- Если выбран $pivot = a_k$​ с $i<k<j$, то $a_i$​ и $a_j$​ попадают в разные части массива и не будут сравниваться в рекурсии.
- Если выбран $pivot =$ $a_i$​ или $a_j$​, то на этом шаге они сравниваются (так как все элементы между ними ещё не разделены).
- Если выбирается $pivot = a_k$ ($k \not\in \overline{i+1,j-1}$), то $a_i$ и $a_j$ остаются в одном блоке, и вопрос об их сравнении откладывается до выбора следующего $pivot$.
Таким образом, **любая пара элементов массива сравнивается не более одного раза**.

Введём СВ, которая будет индикатором того, что элементы сравнивались в процессе сортировки. $$\xi_{ij} = \begin{cases} 1,\ \ a_i\ \text{и}\ a_j\ \text{сравнивались в процессе быстрой сортировки}  \\ 0,\ \ else \end{cases}$$
Рассмотрим множество $S_{ij} = \{a_k|k \in \overline{i,j},\ i \leq j\}$, тогда $|S_{ij}| = j - i + 1$, и в модели равновероятностного выбора $pivot$ из элементов данного множества вероятность, что $pivot = a_i$ или $a_j$ равна $P(pivot \in \{a_i,\ a_j\}) =$ \[Так как по обоснованию выше элементы сравниваются $\Leftrightarrow$ один из них - $pivot$\] $= P(\xi_{ij} = 1) = \frac{2}{j - i + 1}$ ([[Однородное вероятностное пространство|классическая дискретная модель]]). 

Тогда получаем: $C = \sum\limits_{1 \leq i < j \leq n} \xi_{ij}$ и из линейности МО: 
$$\begin{aligned}
\mathbb{E}C = \sum\limits_{1 \leq i < j \leq n} \mathbb{E}\xi_{ij} = \sum\limits_{1 \leq i < j \leq n} P(\xi_{ij} = 1) = \sum\limits_{i=1}^n\sum\limits_{j=i}^n \frac{2}{j - i + 1} = \sum\limits_{i=1}^{n-1}\sum\limits_{k=1}^{n-i} \frac{2}{k + 1} = \sum\limits_{k=1}^{n-1} (n-k) \cdot \frac{2}{k + 1} =\\ 2\sum\limits_{k=1}^{n-1} (\frac{n + 1}{k + 1} - 1) = 2((n + 1)\sum\limits_{k=1}^{n-1} \frac{1}{k + 1} - \sum\limits_{k=1}^{n-1}1) =\\ 2(n+1)(\sum\limits_{k=2}^{n} \frac{1}{k}) - 2(n-1) \leq 2(n+1)\ln n - 2(n-1) = O(n \log n)
\end{aligned}$$

Последнее неравенство докажем по индукции:
**База**: ($n=2$) $\frac{1}{2} \leq \ln 2$ - выполнена
**Предположение**: $\sum\limits_{k=2}^{n} \frac{1}{k} \leq \ln n$
**Шаг**: Покажем, что $\frac{1}{n+1} \leq \ln (n + 1) - \ln n = \ln \frac{n + 1}{n} = \ln (1 + \frac{1}{n})$


- Таким образом, мат. ожидание времени работы быстрой сортировки при случайном выборe $pivot$ равно $O(n \log n)$
