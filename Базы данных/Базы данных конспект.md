# Модели хранения данных

## Разновидности

==Опр.== **База данных (БД, DB)** - совокупность данных, правил их хранения и использования

==Опр.== **Система управления БД (СУБД)** - совокупность программно-лингвистических средств, обеспечивающих создание, управление и использование БД

==Опр.== **Модель данных** - абстрактное самодостаточное логическое определение объектов, операторов и других элементов, составляющих *машину доступа к данным*

Модель данных...
- Организует элементы данных
- Описывает их взаимодействие друг с другом и с объектами внешнего мира

##### Аспекты модели данных:

- **Аспект структуры**. (методы описания типов и логических структур)
- **Аспект манипуляции** (методы манипуляции данными)
- **Аспект целостности** (методы описания и поддержки целостности БД)

### Дореляционные модели данных

##### Иерархическая модель данных

![[Pasted image 20250504124526.png]]

- Древовидная структура записи
- Потомок имеет ровно одного родителя

##### Сетевая модель данных

![[Pasted image 20250504124711.png]]

- Графовидная структура записи
- Расширяет иерархическую модель
- Потомок имеет сколько угодно предков

##### Нереляционная модель данных

![[Pasted image 20250504130305.png]]

- Современные модели данных (часто используются в промышленной разработке и проектировании)
- Данные хранятся неструктурированно (в виде кластеров, семейств, подграфов и т.д.)
- Обеспечивают наиболее быстрый доступ к данным в частных задачах

### Реляционная модель данных

***Далее будем работать в основном только с ней***

![[Pasted image 20250504124949.png]]

#### Основные понятия

==Опр.== **Отношение** - математическая структура данных, которая определяет взаимосвязи различных объектов (~ таблица)

==Опр.== **Алгебра ($\mathcal{A}$)** $\Leftrightarrow\ \mathcal{A} \subset 2^X,$ где $X$ - носитель алгебры (некоторое множество) и $\begin{cases} \emptyset \in \mathcal{A} \\ \forall A \in \mathcal{A}\ :\ 2^X/A \in \mathcal{A} \\ \forall A, B \in \mathcal{A}\ :\ A \cup B \in \mathcal{A} \end{cases}$ 

==Опр.== **Реляционная алгебра (RA, $\mathcal{R}$)** - (алгебра) набор операций, переводящих множество отношений в отношение (~ $\{f\ |\ f: T^n \rightarrow T\}$)

==Опр.== **Домен** - множество допустимых значений в отношении (~ ОДЗ столбца таблицы)

==Опр.== **Атрибут** - наименование домена

==Опр.== **Кортеж** - фиксированный упорядоченный набор данных

==Опр.== **Арность (отношения)** - количество атрибутов отношения

==Опр.== **Заголовок отношения** - список атрибутов отношения

==Опр.== **Тело отношения** - множество всех кортежей в составе отношения

==Опр.== **Совместимые домены** - $A$ совместим с $B\ \Leftrightarrow\ A \subseteq B\ \vee\ B \subseteq A$ 

==Опр.== **Составной домен** - прямое декартовое произведение доменов

##### Операции над отношениями

![[Pasted image 20250504130902.png]]

Пусть $R(E, D)$ - отношение $R$ с телом $E$ и заголовком $D$, а $X$ и $Y$ - произвольные подмножества атрибутов $A$ в $R$.

==Опр.== **Естественное объединение ($\bowtie$)** - $R(E, D) = R_1(E_1, D_1) \bowtie R_2(E_2, D_2) \Leftrightarrow D = D_1 \cup D_2,\ E = E_1 \cup E_2 / X,\ где\ X=\{x \in D\ |\ E_1(x) \neq E_2(x)\}$ 
==Опр.== **Операции ограничения** - $R[A \circ B]=\{r \in R\ |\ r[A] \circ r[B]\}$ (обычно: $\circ \in \{=, \neq, >, \ge, <, \le\}$)

==Опр.== **Пустое тело отношения ($\perp$)** - тело, не имеющее кортежей

==Опр.== **Деление** - $C = A \div B \Leftrightarrow C=max_x\{R[x]\ |\ B\times R \subseteq A\}$ 

==Опр.== **Функциональная зависимость ($\rightarrow$)** - $X \rightarrow Y\ \Leftrightarrow\ \forall t_1, t_2 \in R\ :\ t_1[X] = t_2[X] \Rightarrow t_1[Y] = t_2[Y]$ 

==Опр.== **Детерминант** - левый аргумент функциональной зависимости.

==Опр.== **Зависимый аргумент** - правый аргумент функциональной зависимости.

==Опр.== **Тривиальная функциональная зависимость** - функциональная зависимость, в которой зависимый аргумент является подмножеством детерминанта

==Опр.== **Многозначная зависимость ($\twoheadrightarrow$)** - $X \twoheadrightarrow Y\ \Leftrightarrow\ ]Z = R\ (X \cup Y)\ \forall t_1, t_2 \in R\ :\ t_1[X] = t_2[X] \Rightarrow \exists t_3 \in R\ :\ (t_3[X] = t_1[X]) \wedge (t_3[Y] = t_1[Y]) \wedge (t_3[Z] = t_2[Z])$

# SQL

==Опр.== **SQL (Structured Query Langage)** - ***декларативный*** ЯП для управления данными в реляционной БД с соответствующей СУБД

### Виды операторов

1) **DDL (Data Definition Language)**

Операторы для управления целиковыми объектами БД (не их содержимого!)

Примеры:

	- CREATE
	- ALTER
	- TRUNCATE
	- DROP

2) **DML (Data Manipulation Language)**

Операторы для управления содержимым объектов БД

Примеры:

	- SELECT
	- INSERT
	- UPDATE
	- DELETE

3) **DСL (Data Control Language)**

Операторы для контроля данных

Примеры:

	- GRANT
	- REVOKE

4) **TCL (Transaction Control Language)**

Операторы для управления транзакциями над БД

Примеры:

	- COMMIT
	- ROLLBACK

### Типы данных

#### Числовые типы
##### Целые числа
	- SMALLINT
	- INTEGER
	- BIGINT

##### Приближённые числа
	- NUMERIC
	- DECIMAL

##### Числа с плавающей точкой
	- REAL
	- FLOAT4
	- DOUBLE PRECISION
	- FLOAT8

#### Логический тип
	 - BOOLEAN

#### Символьные типы
	- VARCHAR(n)
	- CHAR(n)
	- TEXT

#### Тип времени
	- DATE
	- TIME
	- TIMESTAMP
	- TIMEWITHTIMEZONE
	- TIMESTAMPWITHTIMEZONE
	- INTERVAL

### Операторы

#### 1. DDL — Операторы определения данных

##### `CREATE`

Создаёт новую таблицу, базу данных, представление, индекс и т. д.

- Можно дописать `IF EXISTS/IF NOT EXISTS` чтобы выполнять только если создаваемый объект уже есть/создаваемого объекта ещё нет

```sql
CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    position VARCHAR(50),
    salary DECIMAL(10, 2)
);

CREATE VIEW employees_count_view;
CREATE INDEX idx_employees_name ON employees(name);
CREATE FUNCTION get_bonus(salary DECIMAL) RETURNS DECIMAL;
```


##### `ALTER`

Изменяет существующую структуру таблицы.

```sql
ALTER TABLE employees ADD COLUMN hire_date DATE;
ALTER TABLE employees DROP COLUMN position;
ALTER TABLE employees RENAME TO workers;
```

  
##### `DROP`

Удаляет объекты базы данных, такие как таблицы, базы данных, представления.

```sql
DROP TABLE employees;
DROP DATABASE warehouse_db;
DROP INDEX idx_employees_name;
```


##### `TRUNCATE`

Очищает таблицу, удаляя все строки без логирования (необратимо, быстрее `DELETE`).

```sql
TRUNCATE TABLE employees;
```

  
#### 2. DML — Операторы управления данными

##### `SELECT`

Извлекает данные из таблиц.

- `SELECT DISTINCT` - чтобы данные не повторялись (выделяет все уникальные значения)
- `SELECT LIMIT n` - выбрать не более n записей

Порядок написания `SELECT`-запросов:
$$SELECT \rightarrow FROM \rightarrow WHERE \rightarrow GROUP\ BY \rightarrow HAVING \rightarrow ORDER\ BY \rightarrow LIMIT$$

Порядок выполнения `SELECT`-запросов:
$$FROM \rightarrow WHERE \rightarrow GROUP\ BY \rightarrow HAVING \rightarrow SELECT \rightarrow ORDER\ BY \rightarrow LIMIT$$

```sql
SELECT * FROM employees;
SELECT name, salary FROM employees WHERE salary > 50000;
```

  
##### `INSERT`

Добавляет новую строку в таблицу.

```sql
INSERT INTO employees (name, position, salary) VALUES ('Ivan', 'Manager', 60000);
```

  
##### `UPDATE`

Изменяет существующие данные.

```sql
UPDATE employees SET salary = salary * 1.1 WHERE position = 'Manager';
```


##### `DELETE`

Удаляет строки из таблицы.

```sql
DELETE FROM employees WHERE id = 1;
```

  
#### 3. DCL — Операторы управления доступом

##### `GRANT`

Предоставляет права пользователям.
```sql
GRANT SELECT, INSERT ON employees TO analyst;
```

  
##### `REVOKE`

Отзывает ранее выданные права.

```sql
REVOKE INSERT ON employees FROM analyst;
```

  
#### 4. TCL — Операторы управления транзакциями

##### `BEGIN` / `START TRANSACTION`

Начинает транзакцию.

```sql
BEGIN;
```


##### `COMMIT`

Фиксирует изменения, сделанные в рамках транзакции.

```sql
COMMIT;
```


##### `ROLLBACK`

Откатывает транзакцию до последнего `BEGIN`.

```sql
ROLLBACK;
```

  
##### `SAVEPOINT`

Создаёт точку сохранения внутри транзакции.

```sql
SAVEPOINT sp1;
```

  
##### `ROLLBACK TO SAVEPOINT`

Откатывается к определённой точке внутри транзакции.

```sql
ROLLBACK TO SAVEPOINT sp1;
```
  

#### 5. Операторы условий и объединений

##### `WHERE`

Фильтрация строк по условию.

```sql
SELECT * FROM employees WHERE salary > 50000;
```


##### `GROUP BY`

Группировка строк по значениям.

```sql
SELECT 
	position,
	avg(salary) 
FROM employees 
GROUP BY position;
```


##### `HAVING`

Фильтрация после группировки.

```sql
SELECT 
	position,
	avg(salary) 
FROM employees
GROUP BY position
HAVING AVG(salary) > 60000;
```


##### `ORDER BY`

Сортировка результатов.

  - `ASC` - сортировка по возрастанию
  - `DESC` - сортировка по убыванию

```sql
SELECT * FROM employees ORDER BY salary DESC;
```

  
#### 6. Прочие полезные операторы

##### `UNION`

Объединяет результаты нескольких запросов (уникальные строки).

```sql
SELECT name FROM clients

UNION

SELECT name FROM suppliers;
```


##### `INTERSECT`

Общие строки между запросами.

```sql
SELECT id FROM table1

INTERSECT

SELECT id FROM table2;
```

  
##### `EXCEPT`

Разница между двумя наборами данных.

```sql
SELECT id FROM table1

EXCEPT

SELECT id FROM table2;
```

#### 7. Объединения таблиц в SQL

##### `INNER JOIN`
Возвращает только те строки, у которых есть совпадения в обеих таблицах по условию соединения. Cтроки без совпадений исключаются из результата.

```sql
SELECT employees.name, departments.name
FROM employees
INNER JOIN departments ON employees.department_id = departments.id;
```


##### `LEFT JOIN`
Возвращает все строки из **левой** таблицы и совпадающие строки из правой. Если в правой таблице нет совпадения — будут `NULL`.

```sql
SELECT employees.name, departments.name
FROM employees
LEFT JOIN departments ON employees.department_id = departments.id;
```


##### `RIGHT JOIN`
Возвращает все строки из **правой** таблицы и совпадающие строки из левой. Если в левой таблице нет совпадения — будут `NULL`.

```sql
SELECT employees.name, departments.name
FROM employees
RIGHT JOIN departments ON employees.department_id = departments.id;
```


##### `FULL JOIN`

Возвращает все строки из обеих таблиц. Если совпадение есть — объединяет. Если нет — подставляет `NULL`.

```sql
SELECT employees.name, departments.name
FROM employees
FULL JOIN departments ON employees.department_id = departments.id;
```


##### `CROSS JOIN`

Декартово произведение: каждая строка из одной таблицы соединяется с каждой строкой другой.

```sql
SELECT e.name, d.name
FROM employees e
CROSS JOIN departments d;
```


##### `SELF JOIN`

Соединение таблицы с самой собой — через псевдонимы.

```sql
SELECT A.name AS employee, B.name AS manager
FROM employees A
JOIN employees B ON A.manager_id = B.id;
```


#### 8. Операторы сравнения

***Применяются в условиях (`WHERE`, `JOIN`, `CASE`, `HAVING` и т.п.).***

| Оператор       | Описание                                                       | Пример                                                                    |
| -------------- | -------------------------------------------------------------- | ------------------------------------------------------------------------- |
| `=`            | Равно                                                          | `salary = 50000`                                                          |
| `<>` или `!=`  | Не равно                                                       | `department_id != 3`                                                      |
| `>`            | Больше                                                         | `salary > 60000`                                                          |
| `<`            | Меньше                                                         | `salary < 40000`                                                          |
| `>=`           | Больше или равно                                               | `salary >= 50000`                                                         |
| `<=`           | Меньше или равно                                               | `hire_date <= '2023-01-01'`                                               |
| `BETWEEN`      | Диапазон значений                                              | `salary BETWEEN 40000 AND 60000`                                          |
| `IS NULL`      | Проверка на `NULL`                                             | `manager_id IS NULL`                                                      |
| `IS NOT NULL`  | Проверка на не `NULL`                                          | `email IS NOT NULL`                                                       |
| `IN`           | Проверка наличия в списке значений                             | `department_id IN (1, 2, 3)`                                              |
| `NOT IN`       | Проверка отсутствия в списке значений                          | `job_title NOT IN ('Manager', 'Intern')`                                  |
| `LIKE`         | Поиск по шаблону, чувствителен к регистру                      | `WHERE name LIKE 'A%'`                                                    |
| `ILIKE`        | (PostgreSQL) То же, что `LIKE`, но без учёта регистра          | `WHERE name ILIKE 'a%'`                                                   |
| `EXISTS`       | Проверка наличия хотя бы одного значения                       | `WHERE EXISTS (SELECT * FROM sales)`                                      |
| `NOT EXISTS`   | Проверка на пустоту или несуществование объекта                | `CREATE TABLE IF NOT EXISTS`                                              |
| `ALL`          | Проверяет чтобы все значения в множестве были истинны          | `WHERE price >= ALL (SELECT price FROM products WHERE price IS NOT NULL)` |
| `ANY`          | Проверяет чтобы хотя бы одно значение в множестве было истинно | `WHERE price >= ALL (SELECT price FROM products WHERE price IS NOT NULL)` |

Операторы `LIKE` и `ILIKE` работают с регулярными выражениями. Вот пару фактов о синтаксисе регулярок в SQL:
- `%` означает несколько (в том числе 0) символов;
- `_` означает ровно 1 символ.

#### 9. Логические операторы

| Оператор | Описание             |
| -------- | -------------------- |
| `AND`    | Логическое И         |
| `OR`     | Логическое ИЛИ       |
| `NOT`    | Логическое отрицание |
| `CASE`   | Условное выражение   |
Пример с `CASE`:

```sql
SELECT name,
       CASE
           WHEN salary > 80000 THEN 'High'
           WHEN salary BETWEEN 50000 AND 80000 THEN 'Medium'
           ELSE 'Low'
       END AS salary_level
FROM employees;
```

##### Тернарная логика

***В тернарной (троичной) логике к стандартным TRUE (T) и FALSE (F) добавляется UNKNOWN (U, он же NULL).***

- Если NULL как-то влияет на результат, то он становится не определён (UNKNOWN)
- Операторы `UNION`, `INTERSECT` и `EXCEPT` считают NULL за одинаковые значения (NULL = NULL), а оператор `UNION ALL` - за различные
- Оператор `DISTINCT` расценивает NULL как известное значение

| Исходное значение | `NOT` результат |
| ----------------- | --------------- |
| **FALSE**         | TRUE            |
| **UNKNOWN**       | UNKNOWN         |
| **TRUE**          | FALSE           |

| `AND`       | FALSE | UNKNOWN | TRUE    |
| ----------- | ----- | ------- | ------- |
| **FALSE**   | FALSE | FALSE   | FALSE   |
| **UNKNOWN** | FALSE | UNKNOWN | UNKNOWN |
| **TRUE**    | FALSE | UNKNOWN | TRUE    |

| `OR`        | FALSE   | UNKNOWN | TRUE |
| ----------- | ------- | ------- | ---- |
| **FALSE**   | FALSE   | UNKNOWN | TRUE |
| **UNKNOWN** | UNKNOWN | UNKNOWN | TRUE |
| **TRUE**    | TRUE    | TRUE    | TRUE |

| Оператор     | Условие                     | При наличии NULL в правой части                                                                |
| ------------ | --------------------------- | ---------------------------------------------------------------------------------------------- |
| **`IN`**     | `value IN (1, 2, NULL)`     | Возвращает: <br>• TRUE (если найдено совпадение) <br>• NULL (если совпадений нет и есть NULL)  |
| **`NOT IN`** | `value NOT IN (1, 2, NULL)` | Возвращает: <br>• FALSE (если найдено совпадение) <br>• NULL (если совпадений нет и есть NULL) |
### Агрегирующие функции

==Опр.== **Агрегирующая функция** - функция, которая выполняет действия над набором данных и возвращает одно результирующее значение

| Функция                        | Описание                                                                   | Пример                                                |
| ------------------------------ | -------------------------------------------------------------------------- | ----------------------------------------------------- |
| `count(val)`                   | Подсчёт количества строк                                                   | `SELECT count(DISTINCT department_id) FROM employees` |
| `sum(val)`                     | Суммирование значений **числового** столбца                                | `SELECT sum(salary) FROM employees`                   |
| `avg(val)`                     | Среднее значение **числового** столбца                                     | `SELECT avg(salary) FROM employees`                   |
| `min(val)`                     | Минимальное значение                                                       | `SELECT min(hire_date) FROM employees`                |
| `max(val)`                     | Максимальное значение                                                      | `SELECT max(hire_date) FROM employees`                |
| `string_agg(value, separator)` | Соединяет значения **текстового** столбца через<br>разделитель `separator` | `SELECT string_agg(name, ' ') FROM employees`         |
| `coalesce(*args)`              | Возвращает первое непустое значение                                        | `SELECT coalesce(*) FROM (NULL, 1, 'hi', NULL, 0)`    |

***Агрегирующие функции игнорируют `NULL`-значения***

Пример подсчёта агрегирующих функций в тернарном массиве (массиве с `NULL`):

`value = (1, NULL, 3, 25, NULL, 0)`

| Функция               | Результат | Объяснение                                           |
| --------------------- | --------- | ---------------------------------------------------- |
| **`sum(value)`**      | 29        | Сумма всех не-NULL значений: `1 + 3 + 25 + 0 = 29`   |
| **`min(value)`**      | 0         | Наименьшее значение среди: `1, 3, 25, 0`             |
| **`max(value)`**      | 25        | Наибольшее значение среди: `1, 3, 25, 0`             |
| **`avg(value)`**      | 7.25      | Среднее значение: `(1 + 3 + 25 + 0) / 4 = 7.25`      |
| **`count(value)`**    | 4         | Количество не-NULL значений: `1, 3, 25, 0` (всего 4) |
| **`coalesce(value)`** | 1         | 1 - первое непустое значение                         |

### Оконные функции

==Опр.== **Окно** - набор или группа кортежей (строк) отношения (таблицы)

==Опр.== **Оконная функция** - функция, которая выполняет вычисления по строкам в пределах окна без агрегации строк

Оконные функции...
- Действуют подобно агрегатным функциям, но не уменьшают степень детализации
- Принимают в качестве аргумента столбец промежуточного результата вычисления и возвращают тоже столбец

==Опр.== **Ранжирование** - упорядочивание строк по значению
некоторого атрибута

==Опр.== **Ранг** - номер строки после ранжирования (вычисляется относительно данного ранжирования)

==Опр.== **Секция** – набор строк из разбиения данных

==Опр.== **Фрейм** – набор строк, участвующий в вычислении функции для данной (рассматриваемой) строки

##### Синтаксис

Если использовать оконную функцию сразу:

```sql
OVER (
	[ <PARTITION BY clause> ]  -- группировка
	[ <ORDER BY clause> ]      -- сортировка
	[ <ROWS or RANGE clause> ] -- фреймы
)
```

Если декларировать функцию:

```sql
WINDOW <name> AS (
	[ <PARTITION BY clause> ]  -- группировка
	[ <ORDER BY clause> ]      -- сортировка
	[ <ROWS or RANGE clause> ] -- фреймы
)
```

- Внутри `OVER` необходимо указать поле таблицы, по которому будет скользить окно, и правило, по которому строки будут секционироваться.
- `OVER` может многократно использоваться в одном `SELECT` с разными разделениями и сортировками.
- Разбивает множество на группы по критериям.
- Агрегации применяются к группам независимо.
- Если не указать конструкцию секционирования, все множество считается одной группой: `OVER` содержит все строки из результирующего набора.

##### Функции ранжирования

| Функция        | Описание                                                                                                                             |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| `row_number()` | порядковый уникальный номер строки                                                                                                   |
| `dense_rank()` | ранг строки (одинаковый у равных строк, у последовательных значений поля сортировки отличается на 1)                                 |
| `rank()`       | ранг строки с пропусками (у последовательных значений поля сортировки отличается на<br>количество строк с одинаковым значением поля) |
| `ntile(n)`     | разбивает все строки на n групп и возвращает номер группы, в<br>которую попала строка                                                |

##### Функции смещения

| Функция                             | Описание                                                                                     |
| ----------------------------------- | -------------------------------------------------------------------------------------------- |
| `lag(attr, offset, default_value)`  | Предыдущее значение поля `attr` со сдвигом `offset` (при отсутствии берётся `default_value`) |
| `lead(attr, offset, default_value)` | Следующее значение поля `attr` со сдвигом `offset` (при отсутствии берётся `default_value`)  |
| `first_value(value)`                | Первое значение в секции с первой по текущую строку (или во фрейме)                          |
| `last_value(value)`                 | Последнее значение во фрейме                                                                 |
| `nth_value(value, n)`               | Значение `value` из n-й строки фрейма                                                        |

##### Скользящие расчёты

Синтаксис:

```sql
<функция>() OVER (
  ORDER BY ...
  ROWS BETWEEN 
	  X (UNBOUNDED) PRECEDING 
		  AND 
	  Y (UNBOUNDED) FOLLOWING
)
```

-> Окно скользит от X-й строки до текущей до Y-й строки после текущей

| Ключевое слово             | Значение                                                                  |
| -------------------------- | ------------------------------------------------------------------------- |
| `X PRECEDING`              | Строка на X позиций **до** текущей                                        |
| `Y FOLLOWING`              | Строка на Y позиций **после** текущей                                     |
| `CURRENT ROW`              | Текущая строка                                                            |
| `UNBOUNDED PRECEDING`      | Самое начало окна                                                         |
| `UNBOUNDED FOLLOWING`      | Самый конец окна                                                          |

Помимо ключевого слова `ROWS` есть слова `RANGE` и `GROUPS`, которые скользят не по позициям,  а по свойствам значений (диапазон значений или ранг значений)

- **`ROWS`** — работает с **позициями** (строками по порядку).

- `RANGE` позволяет включать строки с похожими значениями, а не позициями.

- `GROUPS` работает на основе **рангов** значений в `ORDER BY`, группируя одинаковые значения в одну позицию.

| Пример              | `ROWS`                         | `RANGE`                                       | `GROUPS`                             |
| ------------------- | ------------------------------ | --------------------------------------------- | ------------------------------------ |
| `3 PRECEDING`       | 3 строки до текущей            | Все строки с близкими значениями              | 3 группы значений до текущей         |
| `CURRENT ROW`       | Только текущая строка          | Все строки с тем же значением `ORDER BY`      | Вся текущая группа                   |
| `UNBOUNDED`         | Всё до начала/конца            | Всё по значениям до/после                     | Все группы до начала/конца           |

Примеры: 

1. Скользящее среднее из 2 предыдущих и 2 следующих строк:

```sql
avg(salary) OVER (
  ORDER BY hire_date
  ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING
)
```


2. Все строки с датой в пределах 7 дней

```sql
sum(sales) OVER (
  ORDER BY sale_date
  RANGE BETWEEN INTERVAL '7' DAY PRECEDING AND CURRENT ROW
)
```


3. 1 группа до и 1 после текущей

```sql
sum(sales) OVER (
  ORDER BY category
  GROUPS BETWEEN 1 PRECEDING AND 1 FOLLOWING
)
```

### Подзапросы

==Опр.== **Подзапрос** – запрос, содержащийся в другом SQL-выражении.

- Подзапрос всегда заключен в круглые скобки и обычно выполняется до содержащего выражения;
- Подзапросы могут вкладываться друг в друга;
- В операторе SELECT подзапросы можно использовать во всех разделах, кроме GROUP BY.

Пример:
```sql
SELECT
	name, 
	department,
	salary
FROM employees
WHERE salary = (  -- начало подзапроса
	SELECT max(salary)
	FROM employees
);
```

#### Виды подзапросов

##### По отношению к основному запросу

1. **Несвязные**
	Полностью самодостаточные и не зависящие от основного запроса.
2. **Связные**
	Ссылаются на столбцы основного запроса.

##### По результату

1. **Скалярные**
	- 1 столбец 1 строка
	- можно обращаться без итерации (`salary = (SELECT max(salary) FROM employees);`)
2. **Векторные**
	- 1 столбец несколько строк
	- можно взаимодействовать 'как с массивом'
3. **Табличные**
	- не менее двух столбцов
	- требуют дополнительную итерацию

![[Pasted image 20250506104044.png]]

### Общие табличные выражения

==Опр.== **Общие табличные выражения (Common Table Expressions, CTE)** - временный набор результатов, который определяется в рамках выполнения одного оператора

Синтаксис CTE:

```sql
WITH cte_name AS (
    SELECT column1, column2...
    FROM table_name
    WHERE condition
)
SELECT * FROM cte_name;
```

Основные особенности CTE:

1. **Временные**: существуют только во время выполнения запроса
2. **Именованные**: могут быть вызваны по имени в основном запросе
3. **Рекурсивные**: поддерживают рекурсивные запросы (в большинстве СУБД)

Пример рекурсивного CTE:
- Ключевое слово `RECURSIVE` позволяет ссылаться CTE на собственный вывод.
- Рекурсия прерывается, когда на некоторой итерации возвращается пустой результат.
- `UNION ALL` оставляет все строки при соединении шагов рекурсии с базой, `UNION` – только уникальные значения результата.

```sql
WITH RECURSIVE hierarchy AS (
    -- база рекурсии
    SELECT id, name, manager_id, 1 AS level
    FROM employees
    WHERE manager_id IS NULL

	-- переход рекурсии
    UNION ALL
    
    -- шаг рекурсии
    SELECT e.id, e.name, e.manager_id, h.level + 1
    FROM employees e
    JOIN hierarchy h ON e.manager_id = h.id
)
SELECT * FROM hierarchy ORDER BY level;
```

### Представления (View)

==Опр.== **Представление (View)** - это виртуальная (логическая) таблица, представляющая собой поименованный запрос (синоним к запросу), который будет подставлен как подзапрос при использовании представления.

*Можно ограничивать права доступа пользователей БД, позволяя им пользоваться представлениями, но не писать свои `SELECT`-запросы*

Представление...
- Не является самостоятельной частью данных.
- Вычисляется динамически на основании данных, хранящихся в реальных таблицах.
- Изменение данных в таблицах должно отражаться в содержимом представлений.
- Скрывает от прикладной программы сложность запросов и саму структуру таблиц БД.
- обеспечивают ещё один уровень защиты данных.

==Опр.== **Обновляемое представление** - представление, к которому применимы операции обновления и удаления данных в таблицах, на которых построено это представление.

==Опр.== **Материализованное представление** - записывают и сохраняют результат как в таблицу.

В материализованных представлениях...
- Обращение работает быстрее, но данные могут не всегда быть актуальными.
- Высокое удобство пользования, если нужно быстро обработать исторические данные, а актуальность за последний период не так важна.

| Характеристика             | Достоинства                                                                                                 | Недостатки                                                                           |
| -------------------------- | ----------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| **Безопасность**           | ✅ Ограничение доступа к данным (пользователь видит только то, что разрешено через `VIEW`)                   | ❌ Избыточные права могут нивелировать защиту                                         |
| **Простота использования** | ✅ Работа с `VIEW` как с обычной таблицей (прозрачность для приложений)                                      | ❌ Может скрывать сложность реальных запросов                                         |
| **Гибкость структуры**     | ✅ Абстрагирование от изменений в базовых таблицах (можно менять схему БД без изменения запросов приложений) | ❌ Чрезмерное наслоение `VIEW` усложняет поддержку                                    |
| **Производительность**     | —                                                                                                           | ❌ Возможны проблемы с оптимизацией сложных вложенных `VIEW`                          |
| **Обновляемость**          | ✅ Простые `VIEW` могут быть обновляемыми                                                                    | ❌ Не все `VIEW` поддерживают `INSERT/UPDATE/DELETE` (особенно с агрегациями, `JOIN`) |
| **Управляемость**          | ✅ Логическая организация сложных запросов                                                                   | ❌ "Матрёшка" из вложенных `VIEW` усложняет отладку                                   |

Синтаксис:
```sql
CREATE [OR REPLACE] [TEMP | TEMPORARY] [RECURSIVE]
VIEW view_name [(column_name [,...])]
AS query
[ WITH [ CASCADED | LOCAL ] CHECK OPTION ];
```

- `TEMP | TEMPORARY` – создает временное view, которое исчезнет после окончания сессии.
- `RECURSIVE` – создание рекурсивного view по аналогии с рекурсивными CTE.
- `WITH [ CASCADED | LOCAL ] CHECK OPTION` – правила проверки соответствия добавляемых/обновляемых строк тексту запроса query в случае работы с обновляемыми отношениями.
- `CASCADED` – проверка целостности этого представления и зависимых представлений;
- `LOCAL` – проверка целостности только этого представления.

Критерий обновляемости представления:
- Список `FROM` в запросе, определяющем представлении, должен содержать ровно один элемент, и это должна быть таблица или другое изменяемое представление.
- Определение представления не должно содержать предложения `WITH`, `DISTINCT`, `GROUP BY`, `HAVING`, `LIMIT` и `OFFSET` на верхнем уровне запроса.
- Определение представления не должно содержать операции с множествами (`UNION`, `INTERSECT` и `EXCEPT`) на верхнем уровне запроса.
- Список выборки в запросе не должен содержать агрегатные и оконные функции, а также функции, возвращающие множества.

### Индексы

==Опр.== **Индекс** *(в PostgreSQL)* - специальный объект БД, предназначенный для ускорения доступа к данным.

Это вспомогательные структуры, которые:
- хранятся отдельно от таблицы;
- относятся к одной или нескольким колонкам;
- любой индекс можно удалить и восстановить заново по информации в таблице;
- также служат для поддержки некоторых ограничений целостности.

Синтаксис:
```sql
CREATE [UNIQUE] INDEX [CONCURRENTLY] [name] ON table_name
[USING method] (column1, column2, ...) ...

ALTER INDEX [IF EXISTS] name RENAME TO new_name;
ALTER INDEX [IF EXISTS] name SET TABLESPACE tablespace_name
ALTER INDEX [IF EXISTS] name
	SET (storage_parameter = value [, ... ])
ALTER INDEX [IF EXISTS] name
	RESET (storage_parameter [, ... ])
```

# Проектирование баз данных

==Опр.== **Проектирование БД** - процесс создания детализированной модели данных, а также необходимых ограничений целостности

### Задачи проектирования

1. Обеспечение хранения в БД всей необходимой информации
2. Реализация возможности получения данных по всем необходимым запросам
3. Сокращение избыточности данных
4. Обеспечение целостности БД

### План проектирования

1. **Концептуальное (инфологическое) проектирование**
	1.1) Определение природы и самих данных, с которыми будем работать
	1.2) Определение связей между различными элементами данных
2. **Логическое (даталогическое) проектирование**
	2.1) Наложение логической структуры на данные на основе их отношений
	2.2) Проектирование реляционных отношений между субъектами данных
3. **Физическое проектирование**
	3.1) Создание БД с использованием СУБД

==Опр.== **ER-модель (entity-relationship model)** - модель данных, позволяющая описывать концептуальные и логические схемы.

### Нотация "Воронья лапка"

==Опр.== **Нотация** - система условных обозначений для визуального представления структуры данных и отношений между сущностями.

Нотация "Воронья лапка" - это популярный тип нотации для ER-диаграмм (Entity-Relationship), который наглядно показывает:
- **Сущности** (таблицы) — прямоугольниками
- **Атрибуты** (столбцы) — внутри или рядом с сущностями
- **Связи** между сущностями — линиями с особыми символами на концах

Виды связей:
![[Pasted image 20250505150326.png]]
Пример:
![[Pasted image 20250505150347.png]]

### Ключи в отношениях

==Опр.== **Потенциальный ключ (Candidate key, CK)** - подмножество атрибутов отношения, удовлетворяющее требованиям уникальности и минимальности.

- **Уникальность**: нет и не может быть двух кортежей данного отношения, в которых значения этого подмножества атрибутов совпадают.
- **Минимальность**: в составе потенциального ключа отсутствует меньшее подмножество атрибутов, удовлетворяющее условию уникальности. (Не можем из имеющегося потенциального ключа вычеркнуть атрибут и вновь получить потенциальный ключ)

*Утв.* потенциальный ключ существует всегда, даже если он включает все атрибуты отношения. Более того, допустимо наличие нескольких потенциальных ключей в отношении.

==Опр.== **Первичный ключ ((Primary key, PK)** - один из потенциальных ключей отношения, выбранный в качестве основного.

***!!! Отсутствие значения для PK в логической схеме недопустимо.***

==Опр.== **Альтернативный ключ** - потенциальный ключ, не выбранный в качестве основного.

- Все CK одинаково пригодны для использования в качестве PK, но используется CK, занимающий меньше места при хранении и который не утратит свою уникальность со временем.

==Опр.== **Суррогатный ключ** -  дополнительное служебное поле, которое добавляется к уже имеющимся информационным полям таблицы только чтобы служить первичным ключом.

Суррогатный ключ...
- Значение генерируется искусственно.
- Смысловой нагрузки не несёт.
- Обычно является числовым полем и генерируется за счет авто инкремента.
- Для PostgreSQL это реализовано в типе данных SERIAL.

==Опр.== **Естественный ключ** -  не суррогатный первичный ключ.

==Опр.== **Интеллектуальный ключ** -  ключ, основанный на естественном ключе путём добавления дополнительного поля.

==Опр.== **Внешний ключ (Foreign Key, FK)** -  подмножество атрибутов отношение такое, что в другом отношении имеется PK, равный данному FK с точностью до изменения имён атрибутов и в любой момент времени множество значений данного FK является подмножеством значений того (уже фиксированного) PK.

### Ссылочная целостность и аномалии

==Опр.== **Ссылочная целостность** – необходимое качество реляционной БД, заключающееся в отсутствии в любом её отношении внешних ключей, ссылающихся на несуществующие кортежи.

#### Операторы поддержания ссылочной целостности

| Действие          | Описание                                                                                       | Когда использовать                                                                     | Пример использования                                                      |
| ----------------- | ---------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- | ------------------------------------------------------------------------- |
| **`CASCADE`**     | При удалении/изменении родительской записи, дочерние записи автоматически удаляются/изменяются | Когда дочерние записи не имеют смысла без родительской (например, комментарии к посту) | `FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE`            |
| **`RESTRICT`**    | Запрещает удаление/изменение родительской записи, если существуют зависимые записи             | Когда нужно явно предотвратить потерю связанных данных                                 | `FOREIGN KEY (dept_id) REFERENCES departments(id) ON DELETE RESTRICT`     |
| **`NO ACTION`**   | Аналогично RESTRICT, но проверка выполняется в конце транзакции                                | Когда нужно временно нарушить целостность в рамках транзакции                          | `FOREIGN KEY (order_id) REFERENCES orders(id) ON UPDATE NO ACTION`        |
| **`SET NULL`**    | При удалении родительской записи, внешний ключ устанавливается в NULL                          | Когда связь опциональна, и потеря родителя допустима (например, менеджер товара)       | `FOREIGN KEY (manager_id) REFERENCES employees(id) ON DELETE SET NULL`    |
| **`SET DEFAULT`** | Аналогично SET NULL, но устанавливается значение по умолчанию                                  | Когда есть осмысленное значение по умолчанию для зависимых записей                     | `FOREIGN KEY (status_id) REFERENCES statuses(id) ON DELETE SET DEFAULT 1` |

#### Аномалии

==Опр.== **Аномалия** – ситуация в БД, которая приводит к противоречию в данных или их связях, либо же усложняет обработку данных.

Возможные аномалии:
- Дублирование данных
- Потеря данных
- Неконсистентность данных 
- Неизвестность внешних ключей (аномалия добавления)
- и др.

#### Нормализация БД

==Опр.== **Декомпозиция отношения** – разложение исходной переменной отношения на несколько эквивалентных.

==Опр.== **Декомпозиция без потерь** – обратимая декомпозиция.

==Опр.== **Нормализация БД** – приведение БД к *нормальной форме*.

Нормальная форма БД:
- свойство отношения в реляционной модели данных, характеризующее его с точки зрения избыточности, потенциально приводящей к логически ошибочным результатам выборки или изменениям данных
- совокупность требований, которым должно удовлетворять отношение

![[Pasted image 20250505153631.png]]

##### Первая нормальная форма (1НФ)

Переменная отношения находится в 1НФ тогда и только тогда, когда в любом допустимом значении этой переменной отношения каждый её кортеж содержит скалярное значение для каждого из атрибутов.

##### Вторая нормальная форма (2НФ)

Переменная отношения находится в 2НФ тогда и только тогда, когда она находится в 1НФ и каждый не ключевой атрибут минимально функционально зависит от его первичного ключа.

**Функциональная зависимость** между множествами атрибутов A и B означает, что для любого допустимого набора кортежей в данном отношении верно следующее: если два кортежа совпадают по значению A, то они совпадают по значению B.

**Минимальная функциональная зависимость** означает, что в составе первичного ключа отсутствует меньшее подмножество атрибутов, от которого можно также вывести данную функциональную зависимость.

##### Третья нормальная форма (3НФ)

Переменная отношения находится в 3НФ в том и только в том случае, когда она находится в 1НФ и 2НФ и каждый не ключевой атрибут не транзитивно функционально зависит от первого ключа.


![[Pasted image 20250505154838.png]]
![[Pasted image 20250505154826.png]]

##### Нормальная форма Бойса-Кодда (НФБК)

- **Неприводимость** означает, что в составе потенциального ключа отсутствует меньшее подмножество атрибутов, от которого можно также вывести данную функциональную зависимость.
- Переменная отношения находится в **НФ Бойса-Кодда (НФБК)** в том и только в том случае, тогда и только тогда, когда каждая её нетривиальная и неприводимая слева функциональная зависимость имеет в качестве своего детерминанта некоторый потенциальный ключ .
- Переменная отношения находится в **НФ Бойса-Кодда (НФБК)** в том и только в том случае, когда она находится в 3НФ и не только любой не ключевой атрибут полностью функционально зависит от любого ключа, но и любой ключевой атрибут полностью зависит от любого ключа.

##### Четвёртая нормальная форма (4НФ)

Переменная отношения находится в четвертой нормальной форме тогда и только тогда, когда она находится в НФБК и все многозначные зависимости в ней фактически представляют собой функциональные зависимости от ее ключей.

# Версионность таблиц

*Иногда появляется потребность обратиться к данным, которых уже нет в таблицы. В таком случае будем обращаться к **другой версии таблицы**.*

==Опр.== **Таблица фактов** - основная таблица хранилища данных.

==Опр.== **Таблица измерений** - таблица, содержащая описательные атрибуты и детализацию объектов из таблицы фактов.

##### Схема данных "Звезда"

- В центре схемы находится таблица фактов
- От любого измерения до таблицы фактов можно перейти за один JOIN

![[Pasted image 20250506123404.png]]

##### Схема данных "Снежинка"

- Дополняет схему "Звезда"
- Добавляет иерархию в таблицы измерений

![[Pasted image 20250506123534.png]]

#### Редко изменяющиеся измерения

==Опр.== **Slowly changing dimensions (SCD)** – редко изменяющиеся измерения, то есть измерения, не ключевые атрибуты которых имеют тенденцию со временем изменяться.

- Выделяют 5 типов SCD

##### SCD 0

- После записи данные никогда не изменяются.
- Не поддерживает версионность.
- Является начальной «точкой отсчета» методологии SCD.

##### SCD 1

- Данные записываются поверх существующих значений – очень простая структура, нет избыточности.
- История не сохраняется.
- Используется, если история не нужна.

##### SCD 2

- Каждая версия данных хранится с указанием даты начала и конца периода актуальности.
- Наиболее часто используемый тип.
- Хранит полную и неограниченную историю версий.
- Удобный и простой доступ к данным необходимого периода.
- Провоцирует на избыточность или заведение дополнительных таблиц для хранения изменяемых атрибутов.

##### SCD 3

- В самой записи содержатся дополнительные поля для предыдущих значений атрибута.
- При получении новых данных, старые данные перезаписываются текущими значениями.
- Небольшой объем данных.
- Удобный и простой доступ к истории.
- Ограниченная история.

##### SCD 4

- История изменений содержится в отдельной таблице: основная таблица всегда перезаписывается текущими данными с перенесением старых данных в другую таблицу.
- Обычно этот тип используют для аудита изменений или создания архивных таблиц.
- Быстрая работа с текущими версиями.
- Разделения единой сущности на разные таблицы.

## Транзакции

==Опр.== **Транзакция** - это минимальная логически осмысленная операция, которая имеет смысл и может быть совершена только полностью, переводящая объект транзакции из одного непротиворечивого состояния в другое.

##### Синтаксис

```sql
SET TRANSACTION transaction_mode [, ...]

	ISOLATION LEVEL { SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED }
	
	-- уровень изоляции транзакции
	-- READ UNCOMMITTED в PostgreSQL обрабатывается как READ COMMITTED
	
	READ WRITE | READ ONLY  -- права транзакции на манипуляцию данными
	
	[ NOT ] DEFERRABLE
	
	-- работает только для SERIALIZABLE READ ONLY транзакции;
	-- может продолжить выполняться после блокировки.
```

##### Свойства транзакции (сокращ. ACID)

1. **Атомарность**
	Выполнены либо все внутренние операции, либо никакие
2. **Согласованность (консистентность)**
	Каждая транзакция фиксирует только допустимые (непротиворечивые) результаты
3. **Изолированность**
	Параллельные транзакции не влияют друг на друга
4. **Устойчивость**
	Вне зависимости от сбоев системы, результаты успешных транзакций сохраняются в ней (**Но**! транзакции не устойчивы к *физическим* сбоям, таких как отключение электроэнергии, физическое повреждение устройства или т.п.)

![[Pasted image 20250506125415.png]]

- Транзакцию можно **откатить**, то есть отменить все её изменения, используя оператор `ROLLBACK`

##### Проблемы поддержки изолированности (аномалии)

| Аномалия                   | Описание                                                                                             |
| -------------------------- | ---------------------------------------------------------------------------------------------------- |
| **Потерянное обновление**  | Изменение одного блока данных несколькими транзакциями одновременно                                  |
| **Грязное чтение**         | Чтение данных, которые были изменены другой транзакцией, но затем откачены                           |
| **Неповторяющееся чтение** | Получение разных значений при повторном чтении одних и тех же данных в рамках одной транзакции       |
| **Чтение фантомов**        | Появление новых строк (удовлетворяющих условию выборки) между повторными чтениями в одной транзакции |

##### Уровни изоляции

1. `READ UNCOMMITTED`
	- Данные блокируются на время внесения изменений.
	- На время чтения данных блокировка отсутствует.
	- Гарантирует отсутствие потерянных обновлений.
	- Итоговое значение – результат выполнения каждой транзакции.
	- Возможно считывание незафиксированных изменений.
2. `READ COMMITTED`
	- Блокирование читаемых и изменяемых данных;
	- Сохранение нескольких версий параллельно изменяемых строк.
	- Используется в большей части СУБД.
	- Защита от грязного чтения.
	- В процессе выполнения одна из транзакций успешно завершается, после чего остальные работают с измененными данными.
	- Возможно неповторяющееся чтение.
3. `REPEATABLE READ`
	- Читающая транзакция игнорирует изменения в данных, которые были ей ранее прочитаны.
	- Никакая транзакция не может изменять данные, читаемые текущей транзакцией, пока чтение не завершено.
	- Защищает от неповторяющегося чтения.
4. `SERIALIZABLE`
	- Транзакции полностью изолированы друг от друга – параллельных транзакций как будто бы не существует вовсе.
	- Транзакции не подвержены эффекту фантомного чтения.



ИТОГ: 

| Уровень изоляции       | Характеристика                                                             | Решаемые проблемы                      |
| ---------------------- | -------------------------------------------------------------------------- | -------------------------------------- |
| **`READ UNCOMMITTED`** | Чтение незафиксированных данных                                            | Не решает ни одну из проблем           |
| **`READ COMMITTED`**   | Чтение только зафиксированных данных                                       | Предотвращает грязное чтение           |
| **`REPEATABLE READ`**  | Гарантирует одинаковые результаты при повторных чтениях в одной транзакции | + Предотвращает неповторяющееся чтение |
| **`SERIALIZABLE`**     | Полная изоляция, транзакции выполняются последовательно                    | + Предотвращает чтение фантомов        |

| Проблема \ Уровень изоляции | `READ UNCOMMITTED` | `READ COMMITTED` | `REPEATABLE READ` | `SERIALIZABLE` |
| --------------------------- | ------------------ | ---------------- | ----------------- | -------------- |
| **Потерянное обновление**   | ❌ Не решена        | ✅ Решена         | ✅ Решена          | ✅ Решена       |
| **Грязное чтение**          | ❌ Не решена        | ✅ Решена         | ✅ Решена          | ✅ Решена       |
| **Неповторяющееся чтение**  | ❌ Не решена        | ❌ Не решена      | ✅ Решена          | ✅ Решена       |
| **Фантомное чтение**        | ❌ Не решена        | ❌ Не решена      | ❌ Не решена       | ✅ Решена       |


#### Операторы управления транзакциями

| Оператор                    | Описание                                           | Пример использования              |
| --------------------------- | -------------------------------------------------- | --------------------------------- |
| **`BEGIN`**                 | Начинает блок транзакции                           | `BEGIN;` или `START TRANSACTION;` |
| **`COMMIT`**                | Фиксирует (применяет) транзакцию                   | `COMMIT;`                         |
| **`SAVEPOINT`**             | Создает точку сохранения в транзакции              | `SAVEPOINT backup_point;`         |
| **`ROLLBACK TO SAVEPOINT`** | Откатывает изменения до указанной точки сохранения | `ROLLBACK TO backup_point;`       |
| **`RELEASE SAVEPOINT`**     | Удаляет указанную точку сохранения                 | `RELEASE SAVEPOINT backup_point;` |
| **`ROLLBACK`**              | Откатывает всю текущую транзакцию                  | `ROLLBACK;`                       |

# Жизненный цикл запроса

***Подключение к СУБД $\rightarrow$ отправка запроса в СУБД в формате SQL $\rightarrow$ парсер проверяет корректность синтаксиса $\rightarrow$ парсер формирует дерево запроса $\rightarrow$ система переписывания формирует обновлённое дерево запроса $\rightarrow$ планировщик определяет последовательность выполнения запроса $\rightarrow$ обработчик рекурсивно обходит запрос согласно плану и получает результат***

#### Подключение к СУБД

1. Клиентский процесс обращается к главному
серверному процессу;
2. Главный серверный процесс создает новый
процесс при запросе соединения;
3. Когда соединение установлено, клиент может
отправить на сервер запрос;
4. На этом этапе обработки запроса не происходит.

#### отправка запроса в СУБД

1. Запрос будет передан в виде обычного текста;
2. На этом этапе обработки запроса не происходит.

#### Парсинг запроса

1. Лексический анализатор разбирает текст запроса на лексемы (такие как ключевые слова, строковые и числовые литералы и т. п.), а синтаксический анализатор убеждается, что полученный набор лексем соответствует грамматике языка.
2. Если запрос правильный, строится дерево запроса и передаётся дальше, иначе возвращается ошибка.
3. Лексический и синтаксический анализ реализован с применением следующих средств:
	- Bison – программа для автоматического создания синтаксических анализаторов по описанию грамматики.
	- Flex (fast lexical analyzer) – генератор лексических анализаторов.
4. Происходит проверка наличия доступа у пользователя к запрашиваемым данным.
5. Семантический анализатор получает от синтаксического анализатора дерево разбора и перестраивает его, дополняя ссылками на конкретные объекты базы данных, информацией о типах данных и т.п.
6. Далее запрос может трансформироваться (переписываться) с целью оптимизации и удобства обработки. Например, могут заменяться в дереве разбора имена представлений на поддеревья, соответствующие запросу этого представления.

Упрощённый вид дерева запросов:
![[Pasted image 20250506144135.png]]
*Дерево разбора отражает синтаксическую структуру
запроса, но ничего не говорит о том, в каком порядке
будут выполнены операции.*

#### Планировщик

***Тезис: определенный SQL-запрос можно выполнить разными
способами, при этом получая одни и те же результаты.***

- Планировщик указывает конкретный способ выполнения запроса.
- План выполнения запроса также представляется в виде дерева, но его узлы содержат описание физических операций над данными – это вариант реализации того, что описано в дереве запроса.

Упрощённый вид дерева планировщика:
![[Pasted image 20250506144828.png]]

Оператор `EXPLAIN` (PosthreSQL) способен выводить план выполнения, генерируемый планировщиком. Он показывает:
- как будут сканироваться таблицы, затрагиваемые оператором – последовательно, с использованием индекса и т.д.;
- какой алгоритм соединения будет выбран для объединения считанных из таблиц строк;
- ожидаемую “стоимость” выполнения запроса.
- Оператор **отсутствует** в стандарте SQL
Синтаксис оператора:
```sql
EXPLAIN [ ( option [, ...] ) ] statement
EXPLAIN [ ANALYZE ] [ VERBOSE ] statement
-- where option can be one of:
	ANALYZE [ boolean ] -- запуск запроса и показ реальной статы
	VERBOSE [ boolean ] -- дополнительная информация по плану
	COSTS [ boolean ] -- примерная “стоимость” выполнения
	SETTINGS [ boolean ] -- вывод конфигурационных параметров
	GENERIC_PLAN [ boolean ]
	BUFFERS [ boolean ]
	WAL [ boolean ]
	TIMING [ boolean ]
	SUMMARY [ boolean ] -- общая информация по запросу
	FORMAT { TEXT | XML | JSON | YAML }
```

### Способы считывания данных (на уровне обработчика)

| Способ              | Описание                                                                                                  | Достоинства                                                                                                    | Недостатки                                                                                                                                                                       |
| ------------------- | --------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Seq Scan**        | последовательное чтение данных таблицы, блок за<br>блоком                                                 | При большом объеме данных работает эффективнее индексного сканирования, т.к. считывает данные крупными блоками | Обычно выполняется гораздо медленнее индексного сканирования, так как считывает все данные таблицы.                                                                              |
| **Index Scan**      | для считывания данных с условием `WHERE`<br>используется индекс                                           | При селективности условия время O(N) → O(logN)                                                                 | При увеличении выборки возрастают шансы, что придется возвращаться к одной и той же табличной странице несколько раз.                                                            |
| **Index Only Scan** | используется, если все необходимые значения есть в индексе, в таком случае к таблице почти не обращаемся. | Очень быстрая<br>операция                                                                                      | Может применяться только когда индекс включает все необходимые для выборки поля                                                                                                  |
| **Bitmap Scan**     | сначала используется Index Scan, затем контроль выборки по таблице.                                       | Эффективно для большого общего количества строк при соблюдении селективности                                   | Не ускоряет работу, если условие не является селективным.<br>Если выборка слишком велика для оперативки, при чтении страницы приходится перепроверять условие для каждой строки. |

Более детальное описание работы Bitmap Scan:
1. Запускается Bitmap Index Scan:
	1. каждой странице сопоставляем 1 бит, исходно значение 0;
	2. помечаем единицей те страницы, на которых есть строки, соответствующие нашему условию в WHERE;
	3. передаем битовую карту на уровень выше – Bitmap Heap Scan.
2. Bitmap Heap Scan:
	1. проходит по страницам из битовой карты и оттуда по индексу достает необходимые строки.
	2. В случае почти упорядоченных данных построение битовой карты — лишний шаг, обычное индексное сканирование будет таким же.
	3. Если условия наложены на несколько полей таблицы и эти поля проиндексированы, сканирование битовой карты позволяет (если оптимизатор сочтет это выгодным) использовать несколько индексов одновременно:
		- Для каждого индекса строятся битовые карты версий строк
		- После карты побитово логически умножаются (если выражения соединены условием AND), либо логически складываются (если выражения соединены условием OR)

### Способы соединения таблиц (на уровне обработчика)

| Способ          | Описание                                                                                       | Достоинства                                                                                                                                                                          | Недостатки                                                                                                                                          |
| --------------- | ---------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| **NESTED LOOP** | Последовательно проверяем условия соединения и формируем строку                                | - Дешевый и быстрый на небольших объемах данных;<br>- Хорошо работает с 1 маленькой и 1 большой таблицей;<br>- Не требует много памяти;<br>- Умеет соединять не только по равенству. | - Плохо работает<br>для больших<br>объемов данных.                                                                                                  |
| **HASH JOIN**   | Строим хэш-таблицу по одной из таблиц и значения из второй таблицы сравниваем с хэшами.        | - Не нужен индекс;<br>- Относительно быстрый;<br>- Может быть использован для `FULL OUTER JOIN`.                                                                                     | - Требует много памяти.<br>- Соединение только по равенству.<br>- Большое время получения первой строки<br>- Тратится доп. время на вычисление хэша |
| **MERGE JOIN**  | Сливаем две отсортированных входных таблицы и проверяем условия соединения и формируем строку. | - Быстрый на больших и малых объемах данных;<br>- Не требует много памяти;<br>- Умеет в `OUTER JOIN`;<br>- Подходит для соединения более чем двух таблиц.                            | - Требует отсортированные потоки данных, что подразумевает индекс или сортировку;<br>- Соединение только по равенству.                              |

## Парадигмы OLAP и OLTP

### OLTP

==Опр.== **OLTP (OnLine Transaction Processing)** – тип обработки данных, заключающийся в работе системы с большим потоком небольших по размеру транзакций. 

==Опр.== **Операционная СУБД** – СУБД соответствующая парадигме OLTP. 

***В этой парадигме предполагается, что система предоставляет клиенту отклик за минимальное время.***

![[Pasted image 20250506164924.png]]

Особенности:
- Запрашиваем доступ к отдельным строчкам
- Требуем консистентность и изолированность по строкам
- В целом запросы меняются редко
- Не можем позволить ни стоку, ни балансу уйти в минус – должны аккуратно обрабатывать транзакции
- Предполагается большое количество транзакций

### OLAP

==Опр.== **OLAP (OnLine Analytical Processing)** – технология обработки данных, используемая для анализа бизнес-информации.
- Предполагает подготовку агрегированной информации на основе больших массивов данных.

==Опр.== **Аналитическая СУБД** – СУБД соответствующая парадигме OLAP. 

***Реализации технологии OLAP являются компонентами программных решений класса BI (Business Intelligence).***

==Опр.== **Business Intelligence (BI)** – набор практик по сбору, структурированию, анализу сырых данных и последующему их превращению в картину бизнеса, позволяющую принимать решения.

![[Pasted image 20250506165443.png]]

Особенности
- Транзакционность нужна в меньшей степени
- Обращаемся к большому блоку данных и подмножеству колонок
- Скорее всего не меняем данные
- Идентичные запросы запускаются ограниченное число раз и не особо оптимизируются

### Хранение данных в памяти

==Опр.== **Страничная память** – способ организации виртуальной памяти, при котором виртуальные адреса отображаются на физические постранично.

- Память разбита на страницы – если запросу нужны какие-то данные, он выберет всю страницу.
- Обычно в рамках страницы – данные одной таблицы или индекса, для которых типичны обращения к следующей/предыдущей странице.

Выделяют два вида хранения:
1. **Построчное хранение**
2. **Поколоночное хранение**

##### Построчное хранение
1. **Физическая организация**:
   - Каждая строка хранится как единая непрерывная запись
   - Последовательное расположение полей в блоке памяти

2. **Преимущества**:
   - Быстрый доступ к полной записи по первичному ключу
   - Эффективные операции `INSERT/UPDATE/DELETE`
   - Поддержка транзакций (ACID)

3. **Недостатки**:
   - Чтение избыточных данных при запросе отдельных столбцов
   - Низкая эффективность сжатия

##### Поколоночное хранение
1. **Физическая организация**:
   - Каждый столбец хранится в отдельной структуре
   - Данные разбиваются на страницы/блоки для оптимизации
   
1. **Преимущества**:
   - Высокое сжатие данных
   - Быстрые агрегатные вычисления
   - Эффективное сканирование столбцов

3. **Недостатки**:
   - Замедленные операции записи
   - Сложности с транзакционной целостностью


![[Pasted image 20250506170305.png]]

| Критерий                   | Построчное хранение (Row-oriented)         | Поколоночное хранение (Column-oriented)      |
| -------------------------- | ------------------------------------------ | -------------------------------------------- |
| **Оптимальное применение** | OLTP-системы                               | OLAP-системы                                 |
| **Эффективность записи**   | ✅ Высокая (быстрые `INSERT/UPDATE/DELETE`) | ❌ Низкая (данные распределяются по колонкам) |
| **Эффективность чтения**   | ❌ Низкая (чтение избыточных данных)        | ✅ Высокая (доступ только к нужным колонкам)  |
| **Степень сжатия**         | ❌ Низкая (разнотипные данные в строке)     | ✅ Высокая (однотипные данные в колонке)      |
| **Поддержка ACID**         | ✅ Полная                                   | ⚠️ Ограниченная                              |
| **Типичные СУБД**          | MySQL, PostgreSQL, Oracle                  | ClickHouse, Cassandra, Vertica               |

### Сжатие данных в БД

#### RLE